{"assets": {"openEO_Level1_class-0_129predictors_v1_100000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_100000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/82590597fec10c7e1173d8430685d89f/openEO_Level1_class-0_129predictors_v1_100000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_100000", "statistics": {"maximum": 0.5467734336853, "mean": 0.11103012971527, "minimum": 0.0033486641477793, "stddev": 0.094841665486282, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_100000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level1_class-0_129predictors_v1_110000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_110000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/ad178717f14316acdebd015c2e6ce7e8/openEO_Level1_class-0_129predictors_v1_110000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_110000", "statistics": {"maximum": 0.55654639005661, "mean": 0.11111423827695, "minimum": 0.0058461013250053, "stddev": 0.096715235372765, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_110000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level1_class-0_129predictors_v1_30000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_30000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a95e7c94a833e61cb6748deaec86fa41/openEO_Level1_class-0_129predictors_v1_30000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_30000", "statistics": {"maximum": 0.6880299448967, "mean": 0.1112490808914, "minimum": 0.0039220983162522, "stddev": 0.10233923841864, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_30000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level1_class-0_129predictors_v1_40000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_40000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/18401ad45050e938fed4e3f0d73d110e/openEO_Level1_class-0_129predictors_v1_40000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_40000", "statistics": {"maximum": 0.70374268293381, "mean": 0.11113876065333, "minimum": 0.0019459744216874, "stddev": 0.10536991974846, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_40000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level1_class-0_129predictors_v1_50000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_50000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/35d82506c5b4604d35b9af31201593ed/openEO_Level1_class-0_129predictors_v1_50000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_50000", "statistics": {"maximum": 0.57289671897888, "mean": 0.11134181969006, "minimum": 0.0020658529829234, "stddev": 0.099557145566788, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_50000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level1_class-0_129predictors_v1_60000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_60000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/57361203afb62f5d1b566e4e4e5c074c/openEO_Level1_class-0_129predictors_v1_60000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_60000", "statistics": {"maximum": 0.63351768255234, "mean": 0.11107055113834, "minimum": 0.0022287722676992, "stddev": 0.10349315848783, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_60000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level1_class-0_129predictors_v1_70000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_70000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6c259b2d10445e9a58878169edc2459f/openEO_Level1_class-0_129predictors_v1_70000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_70000", "statistics": {"maximum": 0.67880153656006, "mean": 0.11132728344554, "minimum": 0.0035009372513741, "stddev": 0.10333700186815, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_70000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level1_class-0_129predictors_v1_80000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_80000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/679efba6c6be1827de1ec54b2c499dec/openEO_Level1_class-0_129predictors_v1_80000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_80000", "statistics": {"maximum": 0.63376414775848, "mean": 0.1111557077913, "minimum": 0.0033801449462771, "stddev": 0.10402719860811, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_80000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level1_class-0_129predictors_v1_90000.tif": {"eo:bands": [{"name": "Level1_class-0_129predictors_v1_90000"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/5914bf1ca61d8f4da2f3beb9b4c1a1f1/openEO_Level1_class-0_129predictors_v1_90000.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level1_class-0_129predictors_v1_90000", "statistics": {"maximum": 0.7317128777504, "mean": 0.11118338588857, "minimum": 0.0032661210279912, "stddev": 0.10162569073552, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level1_class-0_129predictors_v1_90000.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-C_71predictors_v1_30100.tif": {"eo:bands": [{"name": "Level2_class-C_71predictors_v1_30100"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/04bde74d55b15a81cb0abecf1b309447/openEO_Level2_class-C_71predictors_v1_30100.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-C_71predictors_v1_30100", "statistics": {"maximum": 0.68084138631821, "mean": 0.33334609366272, "minimum": 0.09863169491291, "stddev": 0.11295942431241, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-C_71predictors_v1_30100.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-C_71predictors_v1_30200.tif": {"eo:bands": [{"name": "Level2_class-C_71predictors_v1_30200"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/656d9081ec9ffc632b96233f72cae9ce/openEO_Level2_class-C_71predictors_v1_30200.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-C_71predictors_v1_30200", "statistics": {"maximum": 0.75464391708374, "mean": 0.3333876843542, "minimum": 0.1002072840929, "stddev": 0.13070230142376, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-C_71predictors_v1_30200.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-C_71predictors_v1_30300.tif": {"eo:bands": [{"name": "Level2_class-C_71predictors_v1_30300"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/9319d00cd5751074f2b9325293a5664b/openEO_Level2_class-C_71predictors_v1_30300.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-C_71predictors_v1_30300", "statistics": {"maximum": 0.71350717544556, "mean": 0.33323587316232, "minimum": 0.10201887786388, "stddev": 0.17025483897466, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-C_71predictors_v1_30300.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-D_68predictors_v1_40100.tif": {"eo:bands": [{"name": "Level2_class-D_68predictors_v1_40100"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/84d73ba4a43f1d24e16ca686550e5f3e/openEO_Level2_class-D_68predictors_v1_40100.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-D_68predictors_v1_40100", "statistics": {"maximum": 0.70157903432846, "mean": 0.24946324767046, "minimum": 0.07217762619257, "stddev": 0.15559886982104, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-D_68predictors_v1_40100.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-D_68predictors_v1_40200.tif": {"eo:bands": [{"name": "Level2_class-D_68predictors_v1_40200"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/c2f57685f2259af163fbf9ec99e90b80/openEO_Level2_class-D_68predictors_v1_40200.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-D_68predictors_v1_40200", "statistics": {"maximum": 0.70127111673355, "mean": 0.2495157747501, "minimum": 0.070928744971752, "stddev": 0.15187174677129, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-D_68predictors_v1_40200.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-D_68predictors_v1_40400.tif": {"eo:bands": [{"name": "Level2_class-D_68predictors_v1_40400"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a3485a0363766d26ced97bb2b3103bfc/openEO_Level2_class-D_68predictors_v1_40400.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-D_68predictors_v1_40400", "statistics": {"maximum": 0.69111454486847, "mean": 0.24934885120546, "minimum": 0.065931431949139, "stddev": 0.15162761104077, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-D_68predictors_v1_40400.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-D_68predictors_v1_40500.tif": {"eo:bands": [{"name": "Level2_class-D_68predictors_v1_40500"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/82cc79247dbf9c618267a79eb40bdd18/openEO_Level2_class-D_68predictors_v1_40500.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-D_68predictors_v1_40500", "statistics": {"maximum": 0.67810082435608, "mean": 0.25015130761634, "minimum": 0.068569749593735, "stddev": 0.091907511878306, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-D_68predictors_v1_40500.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-E_85predictors_v1_50100.tif": {"eo:bands": [{"name": "Level2_class-E_85predictors_v1_50100"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/824bf01bae7db0a6ea6913d4f5a9691e/openEO_Level2_class-E_85predictors_v1_50100.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-E_85predictors_v1_50100", "statistics": {"maximum": 0.47092908620834, "mean": 0.16658225033968, "minimum": 0.049758862704039, "stddev": 0.094797347939244, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-E_85predictors_v1_50100.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-E_85predictors_v1_50200.tif": {"eo:bands": [{"name": "Level2_class-E_85predictors_v1_50200"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/7a4685e0b4bb697a635c8da32d27c0a1/openEO_Level2_class-E_85predictors_v1_50200.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-E_85predictors_v1_50200", "statistics": {"maximum": 0.50144398212433, "mean": 0.1666194052691, "minimum": 0.04778965935111, "stddev": 0.094559101886489, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-E_85predictors_v1_50200.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-E_85predictors_v1_50300.tif": {"eo:bands": [{"name": "Level2_class-E_85predictors_v1_50300"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/86da66f5fb3e77ecbdf502706883b295/openEO_Level2_class-E_85predictors_v1_50300.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-E_85predictors_v1_50300", "statistics": {"maximum": 0.52165013551712, "mean": 0.1661972486625, "minimum": 0.046751260757446, "stddev": 0.094246051690219, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-E_85predictors_v1_50300.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-E_85predictors_v1_50400.tif": {"eo:bands": [{"name": "Level2_class-E_85predictors_v1_50400"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/efcb6cfd185df8dc55cebdea928f0a50/openEO_Level2_class-E_85predictors_v1_50400.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-E_85predictors_v1_50400", "statistics": {"maximum": 0.51640474796295, "mean": 0.16629254088498, "minimum": 0.045625891536474, "stddev": 0.096048373879557, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-E_85predictors_v1_50400.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-E_85predictors_v1_50500.tif": {"eo:bands": [{"name": "Level2_class-E_85predictors_v1_50500"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/8966a5ab085f36a1db31cb2e51081859/openEO_Level2_class-E_85predictors_v1_50500.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-E_85predictors_v1_50500", "statistics": {"maximum": 0.52820289134979, "mean": 0.16621493360703, "minimum": 0.046894766390324, "stddev": 0.089962575875714, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-E_85predictors_v1_50500.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-E_85predictors_v1_50600.tif": {"eo:bands": [{"name": "Level2_class-E_85predictors_v1_50600"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/757021ca8c772cda24331a47b976901a/openEO_Level2_class-E_85predictors_v1_50600.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-E_85predictors_v1_50600", "statistics": {"maximum": 0.31813713908195, "mean": 0.16641956947122, "minimum": 0.082637153565884, "stddev": 0.041224501006085, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-E_85predictors_v1_50600.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-F_90predictors_v1_60200.tif": {"eo:bands": [{"name": "Level2_class-F_90predictors_v1_60200"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b46df9354a451ce254edd8d6c6c22c98/openEO_Level2_class-F_90predictors_v1_60200.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-F_90predictors_v1_60200", "statistics": {"maximum": 0.67449009418488, "mean": 0.19988472335265, "minimum": 0.047881837934256, "stddev": 0.14589078788579, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-F_90predictors_v1_60200.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-F_90predictors_v1_60300.tif": {"eo:bands": [{"name": "Level2_class-F_90predictors_v1_60300"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/46cd30c7d8dab985d3bcaefe445c5468/openEO_Level2_class-F_90predictors_v1_60300.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-F_90predictors_v1_60300", "statistics": {"maximum": 0.67808943986893, "mean": 0.20007611721215, "minimum": 0.045676231384277, "stddev": 0.15984758210253, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-F_90predictors_v1_60300.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-F_90predictors_v1_60400.tif": {"eo:bands": [{"name": "Level2_class-F_90predictors_v1_60400"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/9bc91a657b66f7f67c1c5e7f964a162d/openEO_Level2_class-F_90predictors_v1_60400.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-F_90predictors_v1_60400", "statistics": {"maximum": 0.70074915885925, "mean": 0.20010251571112, "minimum": 0.044422172009945, "stddev": 0.1695308697117, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-F_90predictors_v1_60400.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-F_90predictors_v1_60900.tif": {"eo:bands": [{"name": "Level2_class-F_90predictors_v1_60900"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a768f91bed1c0b476864417c43a844a7/openEO_Level2_class-F_90predictors_v1_60900.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-F_90predictors_v1_60900", "statistics": {"maximum": 0.69796103239059, "mean": 0.19999204523574, "minimum": 0.04509349539876, "stddev": 0.17302405519266, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-F_90predictors_v1_60900.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-F_90predictors_v1_61100.tif": {"eo:bands": [{"name": "Level2_class-F_90predictors_v1_61100"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/f0c0081e43fa4066aec0bc58ef0cbeae/openEO_Level2_class-F_90predictors_v1_61100.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-F_90predictors_v1_61100", "statistics": {"maximum": 0.4332027733326, "mean": 0.20007162134258, "minimum": 0.065539486706257, "stddev": 0.096716392563628, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-F_90predictors_v1_61100.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-G_164predictors_v1_70100.tif": {"eo:bands": [{"name": "Level2_class-G_164predictors_v1_70100"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6fb99085796ba35da915df0292518d2d/openEO_Level2_class-G_164predictors_v1_70100.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-G_164predictors_v1_70100", "statistics": {"maximum": 0.69415944814682, "mean": 0.25019296708162, "minimum": 0.035983201116323, "stddev": 0.1318334619677, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-G_164predictors_v1_70100.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-G_164predictors_v1_70200.tif": {"eo:bands": [{"name": "Level2_class-G_164predictors_v1_70200"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/23f29e1e304f1b6a414b53c304b74ec7/openEO_Level2_class-G_164predictors_v1_70200.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-G_164predictors_v1_70200", "statistics": {"maximum": 0.82250189781189, "mean": 0.25009994654307, "minimum": 0.0287776440382, "stddev": 0.14008047648589, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-G_164predictors_v1_70200.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-G_164predictors_v1_70300.tif": {"eo:bands": [{"name": "Level2_class-G_164predictors_v1_70300"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/d42b881142b3fe4bc7cb2c85f73b4911/openEO_Level2_class-G_164predictors_v1_70300.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-G_164predictors_v1_70300", "statistics": {"maximum": 0.76363480091095, "mean": 0.25013999282874, "minimum": 0.039711318910122, "stddev": 0.13817543704797, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-G_164predictors_v1_70300.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-G_164predictors_v1_70400.tif": {"eo:bands": [{"name": "Level2_class-G_164predictors_v1_70400"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6dbabd903197849958bf61cc63a4ab1c/openEO_Level2_class-G_164predictors_v1_70400.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-G_164predictors_v1_70400", "statistics": {"maximum": 0.65280264616013, "mean": 0.25065471693755, "minimum": 0.052953444421291, "stddev": 0.14105133254598, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-G_164predictors_v1_70400.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-H_65predictors_v1_80200.tif": {"eo:bands": [{"name": "Level2_class-H_65predictors_v1_80200"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/fab2017559734145fdcd602783cff7d0/openEO_Level2_class-H_65predictors_v1_80200.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-H_65predictors_v1_80200", "statistics": {"maximum": 0.95051258802414, "mean": 0.50309064045056, "minimum": 0.049487411975861, "stddev": 0.21481946901011, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-H_65predictors_v1_80200.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-H_65predictors_v1_80300.tif": {"eo:bands": [{"name": "Level2_class-H_65predictors_v1_80300"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/7fe3f8e62b22c356bf8a75d19f2184b0/openEO_Level2_class-H_65predictors_v1_80300.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-H_65predictors_v1_80300", "statistics": {"maximum": 0.95569628477097, "mean": 0.50342743868992, "minimum": 0.044303715229034, "stddev": 0.30408674819386, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-H_65predictors_v1_80300.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-I_50predictors_v1_90100.tif": {"eo:bands": [{"name": "Level2_class-I_50predictors_v1_90100"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/819b5e03e799057c61c909cea7f50074/openEO_Level2_class-I_50predictors_v1_90100.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-I_50predictors_v1_90100", "statistics": {"maximum": 0.98322355747223, "mean": 0.50417367390775, "minimum": 0.016776442527771, "stddev": 0.44791606368582, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-I_50predictors_v1_90100.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-I_50predictors_v1_90200.tif": {"eo:bands": [{"name": "Level2_class-I_50predictors_v1_90200"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/231a01c13eec08f03fd50baa2eba06e1/openEO_Level2_class-I_50predictors_v1_90200.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-I_50predictors_v1_90200", "statistics": {"maximum": 0.98184591531754, "mean": 0.50378998836785, "minimum": 0.018154084682465, "stddev": 0.4108816491264, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-I_50predictors_v1_90200.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-J_62predictors_v1_100100.tif": {"eo:bands": [{"name": "Level2_class-J_62predictors_v1_100100"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/ecf45d06623f9818c2ea166ecd471b48/openEO_Level2_class-J_62predictors_v1_100100.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-J_62predictors_v1_100100", "statistics": {"maximum": 0.43312028050423, "mean": 0.19996849776159, "minimum": 0.076037399470806, "stddev": 0.060315369353083, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-J_62predictors_v1_100100.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-J_62predictors_v1_100200.tif": {"eo:bands": [{"name": "Level2_class-J_62predictors_v1_100200"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/1a56fdd4bae1c97dcf0c7553adf811b1/openEO_Level2_class-J_62predictors_v1_100200.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-J_62predictors_v1_100200", "statistics": {"maximum": 0.4225360751152, "mean": 0.20012133343058, "minimum": 0.076326966285706, "stddev": 0.062721127588239, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-J_62predictors_v1_100200.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-J_62predictors_v1_100300.tif": {"eo:bands": [{"name": "Level2_class-J_62predictors_v1_100300"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/0f1f25cb13e2ef99ed0a5bba86dcc7b5/openEO_Level2_class-J_62predictors_v1_100300.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-J_62predictors_v1_100300", "statistics": {"maximum": 0.45454528927803, "mean": 0.20003485450653, "minimum": 0.070860259234905, "stddev": 0.058773081104873, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-J_62predictors_v1_100300.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-J_62predictors_v1_100400.tif": {"eo:bands": [{"name": "Level2_class-J_62predictors_v1_100400"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/aca9df5c7809374ea55293a23ba8e65f/openEO_Level2_class-J_62predictors_v1_100400.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-J_62predictors_v1_100400", "statistics": {"maximum": 0.46658098697662, "mean": 0.19987270801693, "minimum": 0.072458744049072, "stddev": 0.059126179661213, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-J_62predictors_v1_100400.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-J_62predictors_v1_100600.tif": {"eo:bands": [{"name": "Level2_class-J_62predictors_v1_100600"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/7b93397736a99705050e73fbf481c819/openEO_Level2_class-J_62predictors_v1_100600.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-J_62predictors_v1_100600", "statistics": {"maximum": 0.47201415896416, "mean": 0.20023166820365, "minimum": 0.072477422654629, "stddev": 0.065723398588131, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-J_62predictors_v1_100600.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-X_54predictors_v1_110400.tif": {"eo:bands": [{"name": "Level2_class-X_54predictors_v1_110400"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/fab86db638ca9eb109d8d405e44bcf05/openEO_Level2_class-X_54predictors_v1_110400.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-X_54predictors_v1_110400", "statistics": {"maximum": 0.51493090391159, "mean": 0.20006187203912, "minimum": 0.073503881692886, "stddev": 0.1046901281112, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-X_54predictors_v1_110400.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-X_54predictors_v1_110700.tif": {"eo:bands": [{"name": "Level2_class-X_54predictors_v1_110700"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/15d036274811689bf88514b2deefabf1/openEO_Level2_class-X_54predictors_v1_110700.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-X_54predictors_v1_110700", "statistics": {"maximum": 0.53656595945358, "mean": 0.20000628371304, "minimum": 0.075626067817211, "stddev": 0.10296165295816, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-X_54predictors_v1_110700.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-X_54predictors_v1_110800.tif": {"eo:bands": [{"name": "Level2_class-X_54predictors_v1_110800"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/94b4a54ce053046948aa3d5db12fe7a5/openEO_Level2_class-X_54predictors_v1_110800.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-X_54predictors_v1_110800", "statistics": {"maximum": 0.51375639438629, "mean": 0.19981558524885, "minimum": 0.074496082961559, "stddev": 0.10569511588755, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-X_54predictors_v1_110800.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-X_54predictors_v1_110900.tif": {"eo:bands": [{"name": "Level2_class-X_54predictors_v1_110900"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a0f7f5a67c0b1b864dab7851dd80e2b4/openEO_Level2_class-X_54predictors_v1_110900.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-X_54predictors_v1_110900", "statistics": {"maximum": 0.50982701778412, "mean": 0.19995510980594, "minimum": 0.077047631144524, "stddev": 0.10681805134328, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-X_54predictors_v1_110900.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level2_class-X_54predictors_v1_112100.tif": {"eo:bands": [{"name": "Level2_class-X_54predictors_v1_112100"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/96118af20aaa7d807f7fe2de373ffcaa/openEO_Level2_class-X_54predictors_v1_112100.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level2_class-X_54predictors_v1_112100", "statistics": {"maximum": 0.50946891307831, "mean": 0.1999551593562, "minimum": 0.082524612545967, "stddev": 0.089218239091059, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level2_class-X_54predictors_v1_112100.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-C1_62predictors_v1_30102.tif": {"eo:bands": [{"name": "Level3_class-C1_62predictors_v1_30102"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/077381819ea2842ee5ef4071bae45bf8/openEO_Level3_class-C1_62predictors_v1_30102.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-C1_62predictors_v1_30102", "statistics": {"maximum": 0.9916929602623, "mean": 0.33329896800765, "minimum": 0.0039751073345542, "stddev": 0.43358679855496, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-C1_62predictors_v1_30102.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-C1_62predictors_v1_30103.tif": {"eo:bands": [{"name": "Level3_class-C1_62predictors_v1_30103"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/992d3d3d017457af3302d825d386b348/openEO_Level3_class-C1_62predictors_v1_30103.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-C1_62predictors_v1_30103", "statistics": {"maximum": 0.99181973934174, "mean": 0.33339635467641, "minimum": 0.0039697010070086, "stddev": 0.43636776884075, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-C1_62predictors_v1_30103.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-C1_62predictors_v1_30104.tif": {"eo:bands": [{"name": "Level3_class-C1_62predictors_v1_30104"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/862d6079bf4659e82e4021da23e0d732/openEO_Level3_class-C1_62predictors_v1_30104.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-C1_62predictors_v1_30104", "statistics": {"maximum": 0.99160212278366, "mean": 0.33339087679876, "minimum": 0.0041136266663671, "stddev": 0.37067545567613, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-C1_62predictors_v1_30104.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-C3_62predictors_v1_30302.tif": {"eo:bands": [{"name": "Level3_class-C3_62predictors_v1_30302"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/06d23e30385d68546c34ecc2b897ceba/openEO_Level3_class-C3_62predictors_v1_30302.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-C3_62predictors_v1_30302", "statistics": {"maximum": 0.67211598157883, "mean": 0.33330794422869, "minimum": 0.14078779518604, "stddev": 0.11699500286925, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-C3_62predictors_v1_30302.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-C3_62predictors_v1_30304.tif": {"eo:bands": [{"name": "Level3_class-C3_62predictors_v1_30304"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6cd7406f302cd9fbfb073045f67af8ef/openEO_Level3_class-C3_62predictors_v1_30304.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-C3_62predictors_v1_30304", "statistics": {"maximum": 0.81171381473541, "mean": 0.33328744265939, "minimum": 0.085758417844772, "stddev": 0.15071395268066, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-C3_62predictors_v1_30304.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-C3_62predictors_v1_30305.tif": {"eo:bands": [{"name": "Level3_class-C3_62predictors_v1_30305"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b41c4a5355d6f93ba82a08013712c8d5/openEO_Level3_class-C3_62predictors_v1_30305.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-C3_62predictors_v1_30305", "statistics": {"maximum": 0.66763436794281, "mean": 0.33356416331776, "minimum": 0.14664079248905, "stddev": 0.13318980828897, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-C3_62predictors_v1_30305.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E1_50predictors_v1_50101.tif": {"eo:bands": [{"name": "Level3_class-E1_50predictors_v1_50101"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/302e3643ef18dcc229daf43cf4f69416/openEO_Level3_class-E1_50predictors_v1_50101.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E1_50predictors_v1_50101", "statistics": {"maximum": 0.97831636667252, "mean": 0.49988691823271, "minimum": 0.021683633327484, "stddev": 0.14352897113219, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E1_50predictors_v1_50101.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E1_50predictors_v1_50102.tif": {"eo:bands": [{"name": "Level3_class-E1_50predictors_v1_50102"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/e4a021272a2428bb81c043c23fbdf8e3/openEO_Level3_class-E1_50predictors_v1_50102.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E1_50predictors_v1_50102", "statistics": {"maximum": 0.988973736763, "mean": 0.49788190294581, "minimum": 0.011026263237, "stddev": 0.23530773090746, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E1_50predictors_v1_50102.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E2_50predictors_v1_50201.tif": {"eo:bands": [{"name": "Level3_class-E2_50predictors_v1_50201"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/dc49c571e189298f8e422e200de912c8/openEO_Level3_class-E2_50predictors_v1_50201.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E2_50predictors_v1_50201", "statistics": {"maximum": 0.86172300577164, "mean": 0.24939407077742, "minimum": 0.035531654953957, "stddev": 0.2504760769741, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E2_50predictors_v1_50201.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E2_50predictors_v1_50202.tif": {"eo:bands": [{"name": "Level3_class-E2_50predictors_v1_50202"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b71df33d25a71103f0f38fef42f8b2d6/openEO_Level3_class-E2_50predictors_v1_50202.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E2_50predictors_v1_50202", "statistics": {"maximum": 0.84898084402084, "mean": 0.24909109673768, "minimum": 0.038374524563551, "stddev": 0.2456448294827, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E2_50predictors_v1_50202.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E2_50predictors_v1_50203.tif": {"eo:bands": [{"name": "Level3_class-E2_50predictors_v1_50203"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/61e5b425846cf54074f147b5993f7004/openEO_Level3_class-E2_50predictors_v1_50203.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E2_50predictors_v1_50203", "statistics": {"maximum": 0.83347564935684, "mean": 0.24947222993004, "minimum": 0.039098121225834, "stddev": 0.23974225300246, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E2_50predictors_v1_50203.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E2_50predictors_v1_50206.tif": {"eo:bands": [{"name": "Level3_class-E2_50predictors_v1_50206"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/270c42d7c27f30d3ece12024a4196e4b/openEO_Level3_class-E2_50predictors_v1_50206.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E2_50predictors_v1_50206", "statistics": {"maximum": 0.86172300577164, "mean": 0.24990399994461, "minimum": 0.036902088671923, "stddev": 0.17780533694106, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E2_50predictors_v1_50206.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E3_50predictors_v1_50304.tif": {"eo:bands": [{"name": "Level3_class-E3_50predictors_v1_50304"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/414a20fc89e2871f952e41dab3a1cfe3/openEO_Level3_class-E3_50predictors_v1_50304.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E3_50predictors_v1_50304", "statistics": {"maximum": 0.69317561388016, "mean": 0.50084206659692, "minimum": 0.30682438611984, "stddev": 0.11399084323522, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E3_50predictors_v1_50304.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E3_50predictors_v1_50305.tif": {"eo:bands": [{"name": "Level3_class-E3_50predictors_v1_50305"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/e0a21298f4b60dcdb23745922cc5e40a/openEO_Level3_class-E3_50predictors_v1_50305.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E3_50predictors_v1_50305", "statistics": {"maximum": 0.71513539552689, "mean": 0.50076076050925, "minimum": 0.28486460447311, "stddev": 0.098551901259792, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E3_50predictors_v1_50305.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E4_50predictors_v1_50403.tif": {"eo:bands": [{"name": "Level3_class-E4_50predictors_v1_50403"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/2a86ddbaf0fa6618278e0074692485d0/openEO_Level3_class-E4_50predictors_v1_50403.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E4_50predictors_v1_50403", "statistics": {"maximum": 0.82663601636887, "mean": 0.50129622309223, "minimum": 0.17336398363113, "stddev": 0.13709717182525, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E4_50predictors_v1_50403.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E4_50predictors_v1_50404.tif": {"eo:bands": [{"name": "Level3_class-E4_50predictors_v1_50404"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b636055d38d80efe83e472bbbdfab107/openEO_Level3_class-E4_50predictors_v1_50404.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E4_50predictors_v1_50404", "statistics": {"maximum": 0.91328620910645, "mean": 0.501784702964, "minimum": 0.087359309196472, "stddev": 0.18339939662475, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E4_50predictors_v1_50404.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E5_50predictors_v1_50504.tif": {"eo:bands": [{"name": "Level3_class-E5_50predictors_v1_50504"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/df721dce1fff6f54191c178749cae847/openEO_Level3_class-E5_50predictors_v1_50504.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E5_50predictors_v1_50504", "statistics": {"maximum": 0.63330119848251, "mean": 0.50016724659571, "minimum": 0.36669880151749, "stddev": 0.037317858584623, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E5_50predictors_v1_50504.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-E5_50predictors_v1_50505.tif": {"eo:bands": [{"name": "Level3_class-E5_50predictors_v1_50505"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a3d0d6c8e40b1d16ecc456263db79879/openEO_Level3_class-E5_50predictors_v1_50505.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-E5_50predictors_v1_50505", "statistics": {"maximum": 0.6498481631279, "mean": 0.50044998018522, "minimum": 0.3501518368721, "stddev": 0.058547532161953, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-E5_50predictors_v1_50505.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-F2_60predictors_v1_60202.tif": {"eo:bands": [{"name": "Level3_class-F2_60predictors_v1_60202"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/18e1836801669b66de8fabb414056057/openEO_Level3_class-F2_60predictors_v1_60202.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-F2_60predictors_v1_60202", "statistics": {"maximum": 0.62599700689316, "mean": 0.3333204088185, "minimum": 0.1701367944479, "stddev": 0.17120169841845, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-F2_60predictors_v1_60202.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-F2_60predictors_v1_60203.tif": {"eo:bands": [{"name": "Level3_class-F2_60predictors_v1_60203"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a5e9490ee929b063cf76399c3806bf37/openEO_Level3_class-F2_60predictors_v1_60203.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-F2_60predictors_v1_60203", "statistics": {"maximum": 0.70430713891983, "mean": 0.33333232611602, "minimum": 0.10595980286598, "stddev": 0.17365199260585, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-F2_60predictors_v1_60203.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-F2_60predictors_v1_60204.tif": {"eo:bands": [{"name": "Level3_class-F2_60predictors_v1_60204"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/83d9ee93a92f5db294012e34533033d7/openEO_Level3_class-F2_60predictors_v1_60204.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-F2_60predictors_v1_60204", "statistics": {"maximum": 0.6180847287178, "mean": 0.33332300651262, "minimum": 0.16995015740395, "stddev": 0.15928070747066, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-F2_60predictors_v1_60204.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-F3_50predictors_v1_60301.tif": {"eo:bands": [{"name": "Level3_class-F3_50predictors_v1_60301"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/f12f78ba570b1f8dc85581c574eb8b67/openEO_Level3_class-F3_50predictors_v1_60301.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-F3_50predictors_v1_60301", "statistics": {"maximum": 0.68904536962509, "mean": 0.49994634777386, "minimum": 0.31095463037491, "stddev": 0.12762192800019, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-F3_50predictors_v1_60301.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-F3_50predictors_v1_60302.tif": {"eo:bands": [{"name": "Level3_class-F3_50predictors_v1_60302"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/19e10baa85ba9f9dee3705e0539dacce/openEO_Level3_class-F3_50predictors_v1_60302.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-F3_50predictors_v1_60302", "statistics": {"maximum": 0.69744908809662, "mean": 0.50041184865567, "minimum": 0.30255091190338, "stddev": 0.13225137604421, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-F3_50predictors_v1_60302.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70101.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70101"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/671f54d265ced9c58ffe00d9e07c8722/openEO_Level3_class-G1_74predictors_v1_70101.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70101", "statistics": {"maximum": 0.34845459461212, "mean": 0.11120141268382, "minimum": 0.023238882422447, "stddev": 0.067634351958521, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70101.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70102.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70102"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/8557918d77650c8e1fbcca16152f8ddb/openEO_Level3_class-G1_74predictors_v1_70102.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70102", "statistics": {"maximum": 0.33134135603905, "mean": 0.11109567465038, "minimum": 0.023705633357167, "stddev": 0.065286025133895, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70102.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70104.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70104"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/bb9e018c161f01ea08d4d6f797936c3f/openEO_Level3_class-G1_74predictors_v1_70104.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70104", "statistics": {"maximum": 0.3347307741642, "mean": 0.11103682679956, "minimum": 0.024119719862938, "stddev": 0.065290493653753, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70104.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70105.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70105"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/303e4c5f0591f11728ce78f057531482/openEO_Level3_class-G1_74predictors_v1_70105.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70105", "statistics": {"maximum": 0.35623341798782, "mean": 0.11112311524298, "minimum": 0.023826006799936, "stddev": 0.063029203636898, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70105.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70106.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70106"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6097b23dc10899fc4bf40146e8b91f2c/openEO_Level3_class-G1_74predictors_v1_70106.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70106", "statistics": {"maximum": 0.34925639629364, "mean": 0.11106004751981, "minimum": 0.023434702306986, "stddev": 0.060693872356634, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70106.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70107.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70107"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/581e4154b4c60a05a784dc9e787c0b67/openEO_Level3_class-G1_74predictors_v1_70107.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70107", "statistics": {"maximum": 0.35185033082962, "mean": 0.11106066662337, "minimum": 0.022351088002324, "stddev": 0.060299500059375, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70107.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70108.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70108"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/69c9cab9761a2e38fdbce966d16ca594/openEO_Level3_class-G1_74predictors_v1_70108.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70108", "statistics": {"maximum": 0.3530470430851, "mean": 0.11107852663956, "minimum": 0.022763086482882, "stddev": 0.062559313421446, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70108.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70110.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70110"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/fd74523473f7c520813df18443889768/openEO_Level3_class-G1_74predictors_v1_70110.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70110", "statistics": {"maximum": 0.32601603865623, "mean": 0.11110507060653, "minimum": 0.023258037865162, "stddev": 0.058074020309574, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70110.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G1_74predictors_v1_70113.tif": {"eo:bands": [{"name": "Level3_class-G1_74predictors_v1_70113"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/899acfc0f626b896e8429e7218e2de9a/openEO_Level3_class-G1_74predictors_v1_70113.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G1_74predictors_v1_70113", "statistics": {"maximum": 0.30761912465096, "mean": 0.11112308038955, "minimum": 0.037507444620132, "stddev": 0.072594473732772, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G1_74predictors_v1_70113.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G3_98predictors_v1_70301.tif": {"eo:bands": [{"name": "Level3_class-G3_98predictors_v1_70301"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/ba51e64e5cb7c2a3445292e2c18c441b/openEO_Level3_class-G3_98predictors_v1_70301.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G3_98predictors_v1_70301", "statistics": {"maximum": 0.70885753631592, "mean": 0.25021762592297, "minimum": 0.060593470931053, "stddev": 0.15442497729097, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G3_98predictors_v1_70301.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G3_98predictors_v1_70302.tif": {"eo:bands": [{"name": "Level3_class-G3_98predictors_v1_70302"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/e63f47e1346813da528fe205b02f4837/openEO_Level3_class-G3_98predictors_v1_70302.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G3_98predictors_v1_70302", "statistics": {"maximum": 0.71539181470871, "mean": 0.25020274376693, "minimum": 0.061832845211029, "stddev": 0.15654294928058, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G3_98predictors_v1_70302.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G3_98predictors_v1_70304.tif": {"eo:bands": [{"name": "Level3_class-G3_98predictors_v1_70304"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/34f27605b3bb55115b686f9b57d27344/openEO_Level3_class-G3_98predictors_v1_70304.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G3_98predictors_v1_70304", "statistics": {"maximum": 0.70645266771317, "mean": 0.25032492220305, "minimum": 0.064985074102879, "stddev": 0.15762876862412, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G3_98predictors_v1_70304.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-G3_98predictors_v1_70314.tif": {"eo:bands": [{"name": "Level3_class-G3_98predictors_v1_70314"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/dc8e44cc11c67422164332236bbc9fc1/openEO_Level3_class-G3_98predictors_v1_70314.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-G3_98predictors_v1_70314", "statistics": {"maximum": 0.67434448003769, "mean": 0.25168679141362, "minimum": 0.070079319179058, "stddev": 0.12481117791205, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-G3_98predictors_v1_70314.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-H2_50predictors_v1_80203.tif": {"eo:bands": [{"name": "Level3_class-H2_50predictors_v1_80203"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/117bc99f42d951002deb444482bb7779/openEO_Level3_class-H2_50predictors_v1_80203.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-H2_50predictors_v1_80203", "statistics": {"maximum": 0.63108503818512, "mean": 0.33334169472337, "minimum": 0.1551583558321, "stddev": 0.071384909494703, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-H2_50predictors_v1_80203.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-H2_50predictors_v1_80204.tif": {"eo:bands": [{"name": "Level3_class-H2_50predictors_v1_80204"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/3069c0dbb810908058800763b7d314bc/openEO_Level3_class-H2_50predictors_v1_80204.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-H2_50predictors_v1_80204", "statistics": {"maximum": 0.64756971597672, "mean": 0.33331971707946, "minimum": 0.1454098969698, "stddev": 0.075308980755656, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-H2_50predictors_v1_80204.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-H2_50predictors_v1_80206.tif": {"eo:bands": [{"name": "Level3_class-H2_50predictors_v1_80206"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/46893cf4f25a2d25085b8a7c18c7a1bf/openEO_Level3_class-H2_50predictors_v1_80206.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-H2_50predictors_v1_80206", "statistics": {"maximum": 0.6416340470314, "mean": 0.33343272559573, "minimum": 0.14715646207333, "stddev": 0.14795727307327, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-H2_50predictors_v1_80206.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-H3_50predictors_v1_80301.tif": {"eo:bands": [{"name": "Level3_class-H3_50predictors_v1_80301"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/414336115f7f39f80d001941c7df031f/openEO_Level3_class-H3_50predictors_v1_80301.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-H3_50predictors_v1_80301", "statistics": {"maximum": 0.4813269674778, "mean": 0.33337696635037, "minimum": 0.21972869336605, "stddev": 0.039237657039818, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-H3_50predictors_v1_80301.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-H3_50predictors_v1_80302.tif": {"eo:bands": [{"name": "Level3_class-H3_50predictors_v1_80302"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/8a25f2363b2a3f3f5847886995dc6e20/openEO_Level3_class-H3_50predictors_v1_80302.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-H3_50predictors_v1_80302", "statistics": {"maximum": 0.61598598957062, "mean": 0.3333012065301, "minimum": 0.18759317696095, "stddev": 0.053537382033982, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-H3_50predictors_v1_80302.tif", "type": "image/tiff; application=geotiff"}, "openEO_Level3_class-H3_50predictors_v1_80306.tif": {"eo:bands": [{"name": "Level3_class-H3_50predictors_v1_80306"}], "href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/assets/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/fe5640b0dc24e32bc5097ef639866950/openEO_Level3_class-H3_50predictors_v1_80306.tif?expires=1734517721", "proj:bbox": [4831000, 2817990, 4832010, 2819000], "proj:epsg": 3035, "proj:shape": [101, 101], "raster:bands": [{"name": "Level3_class-H3_50predictors_v1_80306", "statistics": {"maximum": 0.49222034215927, "mean": 0.33341664398678, "minimum": 0.20067630708218, "stddev": 0.050385420663858, "valid_percent": 100.0}}], "roles": ["data"], "title": "openEO_Level3_class-H3_50predictors_v1_80306.tif", "type": "image/tiff; application=geotiff"}}, "description": "Results for batch job j-24121138a9d5477f8506bd402103d59c", "extent": {"spatial": {"bbox": [[16.8771641945754, 48.2606836385078, 16.891804109278915, 48.27047416459093]]}, "temporal": {"interval": [["2021-01-01T00:00:00Z", "2021-02-01T00:00:00Z"]]}}, "id": "j-24121138a9d5477f8506bd402103d59c", "license": "proprietary", "links": [{"href": "/eodata/auxdata/CopDEM/COP-DEM_GLO-30-DGED/DEM1_SAR_DGE_30_20110524T164113_20140403T164309_ADS_000000_BkSe.DEM", "rel": "derived_from", "title": "Derived from /eodata/auxdata/CopDEM/COP-DEM_GLO-30-DGED/DEM1_SAR_DGE_30_20110524T164113_20140403T164309_ADS_000000_BkSe.DEM", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/10/S1A_IW_GRDH_1SDV_20210110T050206_20210110T050231_036071_043A50_4D78_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/16/S1B_IW_GRDH_1SDV_20210116T050112_20210116T050137_025175_02FF56_2880_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051006_20210127T051031_036319_0442F1_983C_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/09/S1B_IW_GRDH_1SDV_20210109T050936_20210109T051001_025073_02FC03_1738_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/27/S1A_IW_GRDH_1SDV_20210127T051008_20210127T051033_036319_0442F1_F111_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/28/S1B_IW_GRDH_1SDV_20210128T050111_20210128T050136_025350_0304E4_9B19_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/04/S1B_IW_GRDH_1SDV_20210104T050112_20210104T050137_025000_02F9B4_E6AA_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051012_20210103T051037_035969_0436B5_D89F_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/03/S1A_IW_GRDH_1SDV_20210103T051007_20210103T051032_035969_0436B5_950D_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051006_20210115T051031_036144_043CD9_80CB_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/21/S1B_IW_GRDH_1SDV_20210121T050935_20210121T051000_025248_03019B_40AE_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/22/S1A_IW_GRDH_1SDV_20210122T050205_20210122T050230_036246_04406B_F294_COG.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-1/SAR/IW_GRDH_1S-COG/2021/01/15/S1A_IW_GRDH_1SDV_20210115T051011_20210115T051036_036144_043CD9_760F_COG.SAFE", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "WENR", "rel": "derived_from", "title": "Derived from WENR", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/10/S2A_MSIL2A_20210110T100401_N0500_R122_T33UXP_20230603T062203.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/10/S2A_MSIL2A_20210110T100401_N0500_R122_T33UXP_20230603T062203.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/15/S2B_MSIL2A_20210115T100249_N0500_R122_T33UXP_20230608T103558.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/15/S2B_MSIL2A_20210115T100249_N0500_R122_T33UXP_20230608T103558.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/25/S2B_MSIL2A_20210125T100209_N0500_R122_T33UXP_20230523T042704.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/25/S2B_MSIL2A_20210125T100209_N0500_R122_T33UXP_20230523T042704.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/17/S2A_MSIL2A_20210117T095341_N0500_R079_T33UXP_20230528T081930.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/17/S2A_MSIL2A_20210117T095341_N0500_R079_T33UXP_20230528T081930.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/20/S2A_MSIL2A_20210120T100331_N0500_R122_T33UXP_20230603T170603.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/20/S2A_MSIL2A_20210120T100331_N0500_R122_T33UXP_20230603T170603.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/27/S2A_MSIL2A_20210127T095251_N0500_R079_T33UXP_20230528T075031.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/27/S2A_MSIL2A_20210127T095251_N0500_R079_T33UXP_20230528T075031.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/07/S2A_MSIL2A_20210107T095401_N0500_R079_T33UXP_20230409T032440.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/07/S2A_MSIL2A_20210107T095401_N0500_R079_T33UXP_20230409T032440.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/30/S2A_MSIL2A_20210130T100241_N0500_R122_T33UXP_20230523T213037.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/30/S2A_MSIL2A_20210130T100241_N0500_R122_T33UXP_20230523T213037.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/10/S2A_MSIL2A_20210110T100401_N0500_R122_T33UXP_20230603T062203.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/10/S2A_MSIL2A_20210110T100401_N0500_R122_T33UXP_20230603T062203.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/15/S2B_MSIL2A_20210115T100249_N0500_R122_T33UXP_20230608T103558.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/15/S2B_MSIL2A_20210115T100249_N0500_R122_T33UXP_20230608T103558.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/25/S2B_MSIL2A_20210125T100209_N0500_R122_T33UXP_20230523T042704.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/25/S2B_MSIL2A_20210125T100209_N0500_R122_T33UXP_20230523T042704.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/17/S2A_MSIL2A_20210117T095341_N0500_R079_T33UXP_20230528T081930.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/17/S2A_MSIL2A_20210117T095341_N0500_R079_T33UXP_20230528T081930.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/20/S2A_MSIL2A_20210120T100331_N0500_R122_T33UXP_20230603T170603.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/20/S2A_MSIL2A_20210120T100331_N0500_R122_T33UXP_20230603T170603.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/27/S2A_MSIL2A_20210127T095251_N0500_R079_T33UXP_20230528T075031.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/27/S2A_MSIL2A_20210127T095251_N0500_R079_T33UXP_20230528T075031.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/07/S2A_MSIL2A_20210107T095401_N0500_R079_T33UXP_20230409T032440.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/07/S2A_MSIL2A_20210107T095401_N0500_R079_T33UXP_20230409T032440.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/30/S2A_MSIL2A_20210130T100241_N0500_R122_T33UXP_20230523T213037.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/30/S2A_MSIL2A_20210130T100241_N0500_R122_T33UXP_20230523T213037.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/27/S2A_MSIL2A_20210127T095251_N0500_R079_T33UXP_20230528T075031.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/27/S2A_MSIL2A_20210127T095251_N0500_R079_T33UXP_20230528T075031.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/10/S2A_MSIL2A_20210110T100401_N0500_R122_T33UXP_20230603T062203.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/10/S2A_MSIL2A_20210110T100401_N0500_R122_T33UXP_20230603T062203.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/15/S2B_MSIL2A_20210115T100249_N0500_R122_T33UXP_20230608T103558.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/15/S2B_MSIL2A_20210115T100249_N0500_R122_T33UXP_20230608T103558.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/25/S2B_MSIL2A_20210125T100209_N0500_R122_T33UXP_20230523T042704.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/25/S2B_MSIL2A_20210125T100209_N0500_R122_T33UXP_20230523T042704.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/17/S2A_MSIL2A_20210117T095341_N0500_R079_T33UXP_20230528T081930.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/17/S2A_MSIL2A_20210117T095341_N0500_R079_T33UXP_20230528T081930.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/20/S2A_MSIL2A_20210120T100331_N0500_R122_T33UXP_20230603T170603.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/20/S2A_MSIL2A_20210120T100331_N0500_R122_T33UXP_20230603T170603.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/30/S2A_MSIL2A_20210130T100241_N0500_R122_T33UXP_20230523T213037.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/30/S2A_MSIL2A_20210130T100241_N0500_R122_T33UXP_20230523T213037.SAFE", "type": "application/json"}, {"href": "/eodata/Sentinel-2/MSI/L2A_N0500/2021/01/07/S2A_MSIL2A_20210107T095401_N0500_R079_T33UXP_20230409T032440.SAFE", "rel": "derived_from", "title": "Derived from /eodata/Sentinel-2/MSI/L2A_N0500/2021/01/07/S2A_MSIL2A_20210107T095401_N0500_R079_T33UXP_20230409T032440.SAFE", "type": "application/json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results", "rel": "self", "type": "application/json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b8248e1c45b002042d6869dd11154417?expires=1734517721", "rel": "canonical", "type": "application/json"}, {"href": "http://ceos.org/ard/files/PFS/SR/v5.0/CARD4L_Product_Family_Specification_Surface_Reflectance-v5.0.pdf", "rel": "card4l-document", "type": "application/pdf"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/82590597fec10c7e1173d8430685d89f/openEO_Level1_class-0_129predictors_v1_100000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/ad178717f14316acdebd015c2e6ce7e8/openEO_Level1_class-0_129predictors_v1_110000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a95e7c94a833e61cb6748deaec86fa41/openEO_Level1_class-0_129predictors_v1_30000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/18401ad45050e938fed4e3f0d73d110e/openEO_Level1_class-0_129predictors_v1_40000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/35d82506c5b4604d35b9af31201593ed/openEO_Level1_class-0_129predictors_v1_50000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/57361203afb62f5d1b566e4e4e5c074c/openEO_Level1_class-0_129predictors_v1_60000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6c259b2d10445e9a58878169edc2459f/openEO_Level1_class-0_129predictors_v1_70000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/679efba6c6be1827de1ec54b2c499dec/openEO_Level1_class-0_129predictors_v1_80000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/5914bf1ca61d8f4da2f3beb9b4c1a1f1/openEO_Level1_class-0_129predictors_v1_90000.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/04bde74d55b15a81cb0abecf1b309447/openEO_Level2_class-C_71predictors_v1_30100.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/656d9081ec9ffc632b96233f72cae9ce/openEO_Level2_class-C_71predictors_v1_30200.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/9319d00cd5751074f2b9325293a5664b/openEO_Level2_class-C_71predictors_v1_30300.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/84d73ba4a43f1d24e16ca686550e5f3e/openEO_Level2_class-D_68predictors_v1_40100.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/c2f57685f2259af163fbf9ec99e90b80/openEO_Level2_class-D_68predictors_v1_40200.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a3485a0363766d26ced97bb2b3103bfc/openEO_Level2_class-D_68predictors_v1_40400.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/82cc79247dbf9c618267a79eb40bdd18/openEO_Level2_class-D_68predictors_v1_40500.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/824bf01bae7db0a6ea6913d4f5a9691e/openEO_Level2_class-E_85predictors_v1_50100.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/7a4685e0b4bb697a635c8da32d27c0a1/openEO_Level2_class-E_85predictors_v1_50200.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/86da66f5fb3e77ecbdf502706883b295/openEO_Level2_class-E_85predictors_v1_50300.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/efcb6cfd185df8dc55cebdea928f0a50/openEO_Level2_class-E_85predictors_v1_50400.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/8966a5ab085f36a1db31cb2e51081859/openEO_Level2_class-E_85predictors_v1_50500.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/757021ca8c772cda24331a47b976901a/openEO_Level2_class-E_85predictors_v1_50600.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b46df9354a451ce254edd8d6c6c22c98/openEO_Level2_class-F_90predictors_v1_60200.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/46cd30c7d8dab985d3bcaefe445c5468/openEO_Level2_class-F_90predictors_v1_60300.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/9bc91a657b66f7f67c1c5e7f964a162d/openEO_Level2_class-F_90predictors_v1_60400.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a768f91bed1c0b476864417c43a844a7/openEO_Level2_class-F_90predictors_v1_60900.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/f0c0081e43fa4066aec0bc58ef0cbeae/openEO_Level2_class-F_90predictors_v1_61100.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6fb99085796ba35da915df0292518d2d/openEO_Level2_class-G_164predictors_v1_70100.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/23f29e1e304f1b6a414b53c304b74ec7/openEO_Level2_class-G_164predictors_v1_70200.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/d42b881142b3fe4bc7cb2c85f73b4911/openEO_Level2_class-G_164predictors_v1_70300.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6dbabd903197849958bf61cc63a4ab1c/openEO_Level2_class-G_164predictors_v1_70400.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/fab2017559734145fdcd602783cff7d0/openEO_Level2_class-H_65predictors_v1_80200.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/7fe3f8e62b22c356bf8a75d19f2184b0/openEO_Level2_class-H_65predictors_v1_80300.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/819b5e03e799057c61c909cea7f50074/openEO_Level2_class-I_50predictors_v1_90100.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/231a01c13eec08f03fd50baa2eba06e1/openEO_Level2_class-I_50predictors_v1_90200.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/ecf45d06623f9818c2ea166ecd471b48/openEO_Level2_class-J_62predictors_v1_100100.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/1a56fdd4bae1c97dcf0c7553adf811b1/openEO_Level2_class-J_62predictors_v1_100200.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/0f1f25cb13e2ef99ed0a5bba86dcc7b5/openEO_Level2_class-J_62predictors_v1_100300.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/aca9df5c7809374ea55293a23ba8e65f/openEO_Level2_class-J_62predictors_v1_100400.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/7b93397736a99705050e73fbf481c819/openEO_Level2_class-J_62predictors_v1_100600.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/fab86db638ca9eb109d8d405e44bcf05/openEO_Level2_class-X_54predictors_v1_110400.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/15d036274811689bf88514b2deefabf1/openEO_Level2_class-X_54predictors_v1_110700.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/94b4a54ce053046948aa3d5db12fe7a5/openEO_Level2_class-X_54predictors_v1_110800.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a0f7f5a67c0b1b864dab7851dd80e2b4/openEO_Level2_class-X_54predictors_v1_110900.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/96118af20aaa7d807f7fe2de373ffcaa/openEO_Level2_class-X_54predictors_v1_112100.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/077381819ea2842ee5ef4071bae45bf8/openEO_Level3_class-C1_62predictors_v1_30102.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/992d3d3d017457af3302d825d386b348/openEO_Level3_class-C1_62predictors_v1_30103.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/862d6079bf4659e82e4021da23e0d732/openEO_Level3_class-C1_62predictors_v1_30104.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/06d23e30385d68546c34ecc2b897ceba/openEO_Level3_class-C3_62predictors_v1_30302.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6cd7406f302cd9fbfb073045f67af8ef/openEO_Level3_class-C3_62predictors_v1_30304.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b41c4a5355d6f93ba82a08013712c8d5/openEO_Level3_class-C3_62predictors_v1_30305.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/302e3643ef18dcc229daf43cf4f69416/openEO_Level3_class-E1_50predictors_v1_50101.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/e4a021272a2428bb81c043c23fbdf8e3/openEO_Level3_class-E1_50predictors_v1_50102.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/dc49c571e189298f8e422e200de912c8/openEO_Level3_class-E2_50predictors_v1_50201.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b71df33d25a71103f0f38fef42f8b2d6/openEO_Level3_class-E2_50predictors_v1_50202.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/61e5b425846cf54074f147b5993f7004/openEO_Level3_class-E2_50predictors_v1_50203.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/270c42d7c27f30d3ece12024a4196e4b/openEO_Level3_class-E2_50predictors_v1_50206.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/414a20fc89e2871f952e41dab3a1cfe3/openEO_Level3_class-E3_50predictors_v1_50304.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/e0a21298f4b60dcdb23745922cc5e40a/openEO_Level3_class-E3_50predictors_v1_50305.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/2a86ddbaf0fa6618278e0074692485d0/openEO_Level3_class-E4_50predictors_v1_50403.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/b636055d38d80efe83e472bbbdfab107/openEO_Level3_class-E4_50predictors_v1_50404.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/df721dce1fff6f54191c178749cae847/openEO_Level3_class-E5_50predictors_v1_50504.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a3d0d6c8e40b1d16ecc456263db79879/openEO_Level3_class-E5_50predictors_v1_50505.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/18e1836801669b66de8fabb414056057/openEO_Level3_class-F2_60predictors_v1_60202.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/a5e9490ee929b063cf76399c3806bf37/openEO_Level3_class-F2_60predictors_v1_60203.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/83d9ee93a92f5db294012e34533033d7/openEO_Level3_class-F2_60predictors_v1_60204.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/f12f78ba570b1f8dc85581c574eb8b67/openEO_Level3_class-F3_50predictors_v1_60301.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/19e10baa85ba9f9dee3705e0539dacce/openEO_Level3_class-F3_50predictors_v1_60302.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/671f54d265ced9c58ffe00d9e07c8722/openEO_Level3_class-G1_74predictors_v1_70101.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/8557918d77650c8e1fbcca16152f8ddb/openEO_Level3_class-G1_74predictors_v1_70102.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/bb9e018c161f01ea08d4d6f797936c3f/openEO_Level3_class-G1_74predictors_v1_70104.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/303e4c5f0591f11728ce78f057531482/openEO_Level3_class-G1_74predictors_v1_70105.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/6097b23dc10899fc4bf40146e8b91f2c/openEO_Level3_class-G1_74predictors_v1_70106.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/581e4154b4c60a05a784dc9e787c0b67/openEO_Level3_class-G1_74predictors_v1_70107.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/69c9cab9761a2e38fdbce966d16ca594/openEO_Level3_class-G1_74predictors_v1_70108.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/fd74523473f7c520813df18443889768/openEO_Level3_class-G1_74predictors_v1_70110.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/899acfc0f626b896e8429e7218e2de9a/openEO_Level3_class-G1_74predictors_v1_70113.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/ba51e64e5cb7c2a3445292e2c18c441b/openEO_Level3_class-G3_98predictors_v1_70301.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/e63f47e1346813da528fe205b02f4837/openEO_Level3_class-G3_98predictors_v1_70302.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/34f27605b3bb55115b686f9b57d27344/openEO_Level3_class-G3_98predictors_v1_70304.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/dc8e44cc11c67422164332236bbc9fc1/openEO_Level3_class-G3_98predictors_v1_70314.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/117bc99f42d951002deb444482bb7779/openEO_Level3_class-H2_50predictors_v1_80203.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/3069c0dbb810908058800763b7d314bc/openEO_Level3_class-H2_50predictors_v1_80204.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/46893cf4f25a2d25085b8a7c18c7a1bf/openEO_Level3_class-H2_50predictors_v1_80206.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/414336115f7f39f80d001941c7df031f/openEO_Level3_class-H3_50predictors_v1_80301.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/8a25f2363b2a3f3f5847886995dc6e20/openEO_Level3_class-H3_50predictors_v1_80302.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}, {"href": "https://openeo.dataspace.copernicus.eu/openeo/1.2/jobs/j-24121138a9d5477f8506bd402103d59c/results/items/YTQyMWY4NDktMmFlNi00MmQzLTkzZjAtYjQzYWEyNTY3ZjFl/fe5640b0dc24e32bc5097ef639866950/openEO_Level3_class-H3_50predictors_v1_80306.tif?expires=1734517721", "rel": "item", "type": "application/geo+json"}], "openeo:status": "finished", "providers": [{"description": "This data was processed on an openEO backend maintained by VITO.", "name": "VITO", "processing:expression": {"expression": {"aggregatetemporalperiod1": {"arguments": {"data": {"from_node": "mask1"}, "period": "dekad", "reducer": {"process_graph": {"median1": {"arguments": {"data": {"from_parameter": "data"}}, "process_id": "median", "result": true}}}}, "process_id": "aggregate_temporal_period"}, "aggregatetemporalperiod2": {"arguments": {"data": {"from_node": "resamplespatial2"}, "period": "dekad", "reducer": {"process_graph": {"mean1": {"arguments": {"data": {"from_parameter": "data"}}, "process_id": "mean", "result": true}}}}, "process_id": "aggregate_temporal_period"}, "apply1": {"arguments": {"data": {"from_node": "aggregatetemporalperiod1"}, "process": {"process_graph": {"linearscalerange1": {"arguments": {"inputMax": 65534, "inputMin": 0, "outputMax": 65534, "outputMin": 0, "x": {"from_parameter": "x"}}, "process_id": "linear_scale_range", "result": true}}}}, "process_id": "apply"}, "apply2": {"arguments": {"data": {"from_node": "apply1"}, "process": {"process_graph": {"linearscalerange2": {"arguments": {"inputMax": 10000, "inputMin": 0, "outputMax": 1, "outputMin": 0, "x": {"from_parameter": "x"}}, "process_id": "linear_scale_range", "result": true}}}}, "process_id": "apply"}, "apply3": {"arguments": {"data": {"from_node": "applydimension2"}, "process": {"process_graph": {"linearscalerange3": {"arguments": {"inputMax": 65534, "inputMin": 1, "outputMax": 65534, "outputMin": 1, "x": {"from_parameter": "x"}}, "process_id": "linear_scale_range", "result": true}}}}, "process_id": "apply"}, "applydimension1": {"arguments": {"data": {"from_node": "apply2"}, "dimension": "bands", "process": {"process_graph": {"add1": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement2"}}, "process_id": "add"}, "add10": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement4"}}, "process_id": "add"}, "add11": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement2"}}, "process_id": "add"}, "add12": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement4"}}, "process_id": "add"}, "add13": {"arguments": {"x": {"from_node": "arrayelement3"}, "y": {"from_node": "arrayelement6"}}, "process_id": "add"}, "add14": {"arguments": {"x": {"from_node": "arrayelement7"}, "y": {"from_node": "arrayelement2"}}, "process_id": "add"}, "add15": {"arguments": {"x": 705, "y": {"from_node": "multiply4"}}, "process_id": "add"}, "add2": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement2"}}, "process_id": "add"}, "add3": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement4"}}, "process_id": "add"}, "add4": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement1"}}, "process_id": "add"}, "add5": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement2"}}, "process_id": "add"}, "add6": {"arguments": {"x": {"from_node": "add5"}, "y": {"from_node": "arrayelement6"}}, "process_id": "add"}, "add7": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement2"}}, "process_id": "add"}, "add8": {"arguments": {"x": {"from_node": "add7"}, "y": {"from_node": "arrayelement6"}}, "process_id": "add"}, "add9": {"arguments": {"x": {"from_node": "divide7"}, "y": {"from_node": "arrayelement4"}}, "process_id": "add"}, "arrayelement1": {"arguments": {"data": {"from_parameter": "data"}, "index": 6}, "process_id": "array_element"}, "arrayelement2": {"arguments": {"data": {"from_parameter": "data"}, "index": 2}, "process_id": "array_element"}, "arrayelement3": {"arguments": {"data": {"from_parameter": "data"}, "index": 3}, "process_id": "array_element"}, "arrayelement4": {"arguments": {"data": {"from_parameter": "data"}, "index": 8}, "process_id": "array_element"}, "arrayelement5": {"arguments": {"data": {"from_parameter": "data"}, "index": 1}, "process_id": "array_element"}, "arrayelement6": {"arguments": {"data": {"from_parameter": "data"}, "index": 9}, "process_id": "array_element"}, "arrayelement7": {"arguments": {"data": {"from_parameter": "data"}, "index": 5}, "process_id": "array_element"}, "arrayelement8": {"arguments": {"data": {"from_parameter": "data"}, "index": 4}, "process_id": "array_element"}, "arraymodify1": {"arguments": {"data": {"from_parameter": "data"}, "index": 10, "values": [{"from_node": "divide1"}, {"from_node": "power1"}, {"from_node": "subtract4"}, {"from_node": "multiply3"}, {"from_node": "divide4"}, {"from_node": "divide5"}, {"from_node": "divide8"}, {"from_node": "divide9"}, {"from_node": "subtract12"}, {"from_node": "divide12"}, {"from_node": "add15"}, {"from_node": "divide16"}]}, "process_id": "array_modify", "result": true}, "divide1": {"arguments": {"x": {"from_node": "subtract1"}, "y": {"from_node": "add1"}}, "process_id": "divide"}, "divide10": {"arguments": {"x": {"from_node": "subtract10"}, "y": {"from_node": "add11"}}, "process_id": "divide"}, "divide11": {"arguments": {"x": {"from_node": "subtract11"}, "y": {"from_node": "add12"}}, "process_id": "divide"}, "divide12": {"arguments": {"x": {"from_node": "subtract13"}, "y": {"from_node": "add13"}}, "process_id": "divide"}, "divide13": {"arguments": {"x": {"from_node": "add14"}, "y": 2}, "process_id": "divide"}, "divide14": {"arguments": {"x": {"from_node": "subtract14"}, "y": {"from_node": "subtract15"}}, "process_id": "divide"}, "divide15": {"arguments": {"x": {"from_node": "arrayelement3"}, "y": {"from_node": "arrayelement8"}}, "process_id": "divide"}, "divide16": {"arguments": {"x": {"from_node": "subtract16"}, "y": {"from_node": "divide15"}}, "process_id": "divide"}, "divide2": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement3"}}, "process_id": "divide"}, "divide3": {"arguments": {"x": {"from_node": "subtract5"}, "y": {"from_node": "add2"}}, "process_id": "divide"}, "divide4": {"arguments": {"x": {"from_node": "subtract6"}, "y": {"from_node": "add3"}}, "process_id": "divide"}, "divide5": {"arguments": {"x": {"from_node": "subtract7"}, "y": {"from_node": "add4"}}, "process_id": "divide"}, "divide6": {"arguments": {"x": {"from_node": "add6"}, "y": 3}, "process_id": "divide"}, "divide7": {"arguments": {"x": {"from_node": "add8"}, "y": 3}, "process_id": "divide"}, "divide8": {"arguments": {"x": {"from_node": "subtract8"}, "y": {"from_node": "add9"}}, "process_id": "divide"}, "divide9": {"arguments": {"x": {"from_node": "subtract9"}, "y": {"from_node": "add10"}}, "process_id": "divide"}, "multiply1": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "subtract2"}}, "process_id": "multiply"}, "multiply2": {"arguments": {"x": {"from_node": "multiply1"}, "y": {"from_node": "subtract3"}}, "process_id": "multiply"}, "multiply3": {"arguments": {"x": {"from_node": "divide3"}, "y": {"from_node": "arrayelement1"}}, "process_id": "multiply"}, "multiply4": {"arguments": {"x": 35, "y": {"from_node": "divide14"}}, "process_id": "multiply"}, "power1": {"arguments": {"base": {"from_node": "multiply2"}, "p": 0.3333333333333333}, "process_id": "power"}, "subtract1": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement2"}}, "process_id": "subtract"}, "subtract10": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement2"}}, "process_id": "subtract"}, "subtract11": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement4"}}, "process_id": "subtract"}, "subtract12": {"arguments": {"x": {"from_node": "divide10"}, "y": {"from_node": "divide11"}}, "process_id": "subtract"}, "subtract13": {"arguments": {"x": {"from_node": "arrayelement3"}, "y": {"from_node": "arrayelement6"}}, "process_id": "subtract"}, "subtract14": {"arguments": {"x": {"from_node": "divide13"}, "y": {"from_node": "arrayelement3"}}, "process_id": "subtract"}, "subtract15": {"arguments": {"x": {"from_node": "arrayelement8"}, "y": {"from_node": "arrayelement3"}}, "process_id": "subtract"}, "subtract16": {"arguments": {"x": {"from_node": "arrayelement7"}, "y": {"from_node": "arrayelement2"}}, "process_id": "subtract"}, "subtract2": {"arguments": {"x": 1, "y": {"from_node": "arrayelement2"}}, "process_id": "subtract"}, "subtract3": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement2"}}, "process_id": "subtract"}, "subtract4": {"arguments": {"x": {"from_node": "divide2"}, "y": 1}, "process_id": "subtract"}, "subtract5": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement2"}}, "process_id": "subtract"}, "subtract6": {"arguments": {"x": {"from_node": "arrayelement1"}, "y": {"from_node": "arrayelement4"}}, "process_id": "subtract"}, "subtract7": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement1"}}, "process_id": "subtract"}, "subtract8": {"arguments": {"x": {"from_node": "divide6"}, "y": {"from_node": "arrayelement4"}}, "process_id": "subtract"}, "subtract9": {"arguments": {"x": {"from_node": "arrayelement5"}, "y": {"from_node": "arrayelement4"}}, "process_id": "subtract"}}}}, "process_id": "apply_dimension"}, "applydimension10": {"arguments": {"data": {"from_node": "filterbands6"}, "dimension": "bands", "process": {"process_graph": {"runudf5": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-F_90predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension11": {"arguments": {"data": {"from_node": "filterbands7"}, "dimension": "bands", "process": {"process_graph": {"runudf6": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-G_164predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension12": {"arguments": {"data": {"from_node": "filterbands8"}, "dimension": "bands", "process": {"process_graph": {"runudf7": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-H_65predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension13": {"arguments": {"data": {"from_node": "filterbands9"}, "dimension": "bands", "process": {"process_graph": {"runudf8": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-I_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension14": {"arguments": {"data": {"from_node": "filterbands10"}, "dimension": "bands", "process": {"process_graph": {"runudf9": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-J_62predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension15": {"arguments": {"data": {"from_node": "filterbands11"}, "dimension": "bands", "process": {"process_graph": {"runudf10": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-X_54predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension16": {"arguments": {"data": {"from_node": "filterbands12"}, "dimension": "bands", "process": {"process_graph": {"runudf11": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-C1_62predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension17": {"arguments": {"data": {"from_node": "filterbands13"}, "dimension": "bands", "process": {"process_graph": {"runudf12": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-C3_62predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension18": {"arguments": {"data": {"from_node": "filterbands14"}, "dimension": "bands", "process": {"process_graph": {"runudf13": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-E1_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension19": {"arguments": {"data": {"from_node": "filterbands15"}, "dimension": "bands", "process": {"process_graph": {"runudf14": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-E2_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension2": {"arguments": {"data": {"from_node": "aggregatetemporalperiod2"}, "dimension": "bands", "process": {"process_graph": {"add16": {"arguments": {"x": {"from_node": "multiply5"}, "y": 83}, "process_id": "add"}, "add17": {"arguments": {"x": {"from_node": "multiply6"}, "y": 83}, "process_id": "add"}, "arraycreate1": {"arguments": {"data": [{"from_node": "if1"}, {"from_node": "if2"}]}, "process_id": "array_create", "result": true}, "arrayelement10": {"arguments": {"data": {"from_parameter": "data"}, "index": 0}, "process_id": "array_element"}, "arrayelement11": {"arguments": {"data": {"from_parameter": "data"}, "index": 1}, "process_id": "array_element"}, "arrayelement12": {"arguments": {"data": {"from_parameter": "data"}, "index": 1}, "process_id": "array_element"}, "arrayelement9": {"arguments": {"data": {"from_parameter": "data"}, "index": 0}, "process_id": "array_element"}, "divide17": {"arguments": {"x": {"from_node": "add16"}, "y": 20}, "process_id": "divide"}, "divide18": {"arguments": {"x": {"from_node": "add17"}, "y": 20}, "process_id": "divide"}, "if1": {"arguments": {"accept": 1, "reject": {"from_node": "power2"}, "value": {"from_node": "isnodata1"}}, "process_id": "if"}, "if2": {"arguments": {"accept": 1, "reject": {"from_node": "power3"}, "value": {"from_node": "isnodata2"}}, "process_id": "if"}, "isnodata1": {"arguments": {"x": {"from_node": "arrayelement10"}}, "process_id": "is_nodata"}, "isnodata2": {"arguments": {"x": {"from_node": "arrayelement12"}}, "process_id": "is_nodata"}, "log1": {"arguments": {"base": 10, "x": {"from_node": "arrayelement9"}}, "process_id": "log"}, "log2": {"arguments": {"base": 10, "x": {"from_node": "arrayelement11"}}, "process_id": "log"}, "multiply5": {"arguments": {"x": 10, "y": {"from_node": "log1"}}, "process_id": "multiply"}, "multiply6": {"arguments": {"x": 10, "y": {"from_node": "log2"}}, "process_id": "multiply"}, "power2": {"arguments": {"base": 10, "p": {"from_node": "divide17"}}, "process_id": "power"}, "power3": {"arguments": {"base": 10, "p": {"from_node": "divide18"}}, "process_id": "power"}}}}, "process_id": "apply_dimension"}, "applydimension20": {"arguments": {"data": {"from_node": "filterbands16"}, "dimension": "bands", "process": {"process_graph": {"runudf15": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-E3_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension21": {"arguments": {"data": {"from_node": "filterbands17"}, "dimension": "bands", "process": {"process_graph": {"runudf16": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-E4_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension22": {"arguments": {"data": {"from_node": "filterbands18"}, "dimension": "bands", "process": {"process_graph": {"runudf17": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-E5_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension23": {"arguments": {"data": {"from_node": "filterbands19"}, "dimension": "bands", "process": {"process_graph": {"runudf18": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-F2_60predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension24": {"arguments": {"data": {"from_node": "filterbands20"}, "dimension": "bands", "process": {"process_graph": {"runudf19": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-F3_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension25": {"arguments": {"data": {"from_node": "filterbands21"}, "dimension": "bands", "process": {"process_graph": {"runudf20": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-G1_74predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension26": {"arguments": {"data": {"from_node": "filterbands22"}, "dimension": "bands", "process": {"process_graph": {"runudf21": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-G3_98predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension27": {"arguments": {"data": {"from_node": "filterbands23"}, "dimension": "bands", "process": {"process_graph": {"runudf22": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-H2_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension28": {"arguments": {"data": {"from_node": "filterbands24"}, "dimension": "bands", "process": {"process_graph": {"runudf23": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level3_class-H3_50predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension3": {"arguments": {"data": {"from_node": "apply3"}, "dimension": "bands", "process": {"process_graph": {"arraycreate2": {"arguments": {"data": [{"from_node": "subtract17"}, {"from_node": "subtract18"}]}, "process_id": "array_create", "result": true}, "arrayelement13": {"arguments": {"data": {"from_parameter": "data"}, "index": 0}, "process_id": "array_element"}, "arrayelement14": {"arguments": {"data": {"from_parameter": "data"}, "index": 1}, "process_id": "array_element"}, "log3": {"arguments": {"base": 10, "x": {"from_node": "arrayelement13"}}, "process_id": "log"}, "log4": {"arguments": {"base": 10, "x": {"from_node": "arrayelement14"}}, "process_id": "log"}, "multiply7": {"arguments": {"x": 20, "y": {"from_node": "log3"}}, "process_id": "multiply"}, "multiply8": {"arguments": {"x": 20, "y": {"from_node": "log4"}}, "process_id": "multiply"}, "subtract17": {"arguments": {"x": {"from_node": "multiply7"}, "y": 83}, "process_id": "subtract"}, "subtract18": {"arguments": {"x": {"from_node": "multiply8"}, "y": 83}, "process_id": "subtract"}}}}, "process_id": "apply_dimension"}, "applydimension4": {"arguments": {"context": {"TileSize": 128, "parallel": true}, "data": {"from_node": "applydimension3"}, "dimension": "bands", "process": {"process_graph": {"add18": {"arguments": {"x": {"from_node": "arrayelement15"}, "y": {"from_node": "arrayelement16"}}, "process_id": "add"}, "arraycreate3": {"arguments": {"data": [{"from_node": "arrayelement15"}, {"from_node": "arrayelement16"}, {"from_node": "divide19"}, {"from_node": "subtract19"}, {"from_node": "divide20"}]}, "process_id": "array_create", "result": true}, "arrayelement15": {"arguments": {"data": {"from_parameter": "data"}, "label": "VV"}, "process_id": "array_element"}, "arrayelement16": {"arguments": {"data": {"from_parameter": "data"}, "label": "VH"}, "process_id": "array_element"}, "divide19": {"arguments": {"x": {"from_node": "multiply9"}, "y": {"from_node": "add18"}}, "process_id": "divide"}, "divide20": {"arguments": {"x": {"from_node": "arrayelement16"}, "y": {"from_node": "arrayelement15"}}, "process_id": "divide"}, "multiply9": {"arguments": {"x": 4, "y": {"from_node": "arrayelement16"}}, "process_id": "multiply"}, "subtract19": {"arguments": {"x": {"from_node": "arrayelement16"}, "y": {"from_node": "arrayelement15"}}, "process_id": "subtract"}}}}, "process_id": "apply_dimension"}, "applydimension5": {"arguments": {"context": {"TileSize": 128, "parallel": true}, "data": {"from_node": "mergecubes1"}, "dimension": "t", "process": {"process_graph": {"arrayconcat1": {"arguments": {"array1": {"from_node": "quantiles1"}, "array2": [{"from_node": "mean2"}, {"from_node": "sd1"}, {"from_node": "sum1"}, {"from_node": "subtract20"}]}, "process_id": "array_concat", "result": true}, "mean2": {"arguments": {"data": {"from_parameter": "data"}}, "process_id": "mean"}, "quantiles1": {"arguments": {"data": {"from_parameter": "data"}, "probabilities": [0.02, 0.25, 0.5, 0.75, 0.98]}, "process_id": "quantiles"}, "quantiles2": {"arguments": {"data": {"from_parameter": "data"}, "probabilities": [0.75]}, "process_id": "quantiles"}, "quantiles3": {"arguments": {"data": {"from_parameter": "data"}, "probabilities": [0.25]}, "process_id": "quantiles"}, "sd1": {"arguments": {"data": {"from_parameter": "data"}}, "process_id": "sd"}, "subtract20": {"arguments": {"x": {"from_node": "quantiles2"}, "y": {"from_node": "quantiles3"}}, "process_id": "subtract"}, "sum1": {"arguments": {"data": {"from_parameter": "data"}}, "process_id": "sum"}}}, "target_dimension": "bands"}, "process_id": "apply_dimension"}, "applydimension6": {"arguments": {"data": {"from_node": "filterbands2"}, "dimension": "bands", "process": {"process_graph": {"runudf1": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level1_class-0_129predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension7": {"arguments": {"data": {"from_node": "filterbands3"}, "dimension": "bands", "process": {"process_graph": {"runudf2": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-C_71predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension8": {"arguments": {"data": {"from_node": "filterbands4"}, "dimension": "bands", "process": {"process_graph": {"runudf3": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-D_68predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "applydimension9": {"arguments": {"data": {"from_node": "filterbands5"}, "dimension": "bands", "process": {"process_graph": {"runudf4": {"arguments": {"context": {"model_url": "https://s3.waw3-1.cloudferro.com/swift/v1/ecdc-waw3-1-ekqouvq3otv8hmw0njzuvo0g4dy0ys8r985n7dggjis3erkpn5o/models/Level2_class-E_85predictors_v1.onnx"}, "data": {"from_parameter": "data"}, "runtime": "Python", "udf": "# /// script\n# dependencies = [\n# \"filelock\",\n# \"onnxruntime\",\n# ]\n# ///\n\nimport os\nimport functools\nimport requests\nimport tempfile\nimport onnxruntime as ort\nimport xarray as xr\nimport numpy as np\nimport shutil\nfrom urllib.parse import urlparse\nfrom openeo.udf import inspect\nfrom typing import Dict\nfrom filelock import FileLock\n\n\ndef is_zip_file(url: str) -> bool:\n    \"\"\"Check if the URL points to a ZIP file.\"\"\"\n    return url.lower().endswith('.zip')\n\ndef is_onnx_file(file_path: str) -> bool:\n    \"\"\"Check if the file is an ONNX model based on its extension.\"\"\"\n    return file_path.endswith('.onnx')\n    \ndef download_file_with_lock(url: str, max_file_size_mb: int = 100, cache_dir: str = '/tmp/cache') -> str:\n    \"\"\"Download a file with concurrency protection and store it temporarily.\"\"\"\n    \n    # Extract the file name from the URL (e.g., \"model_1.onnx\")\n    file_name = os.path.basename(urlparse(url).path)\n    \n    # Construct the file path within the cache directory (e.g., '/tmp/cache/model.onnx')\n    file_path = os.path.join(cache_dir, file_name)\n    \n    # Lock file to prevent concurrent downloads\n    lock_path = file_path + '.download.lock'\n    lock = FileLock(lock_path)\n    \n    with lock:\n        # Check if the file already exists in the cache\n        if os.path.exists(file_path):\n            print(f\"File {file_path} already exists in cache.\")\n            return file_path\n        \n        try:\n            # Download the file to a temporary location\n            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=\".onnx\")\n            temp_file_path = temp_file.name  # Store the temporary file path\n            \n            inspect(message=f\"Downloading file from {url}...\")\n            response = requests.get(url, stream=True)\n            if response.status_code == 200:\n                file_size = 0\n                with temp_file:\n                    for chunk in response.iter_content(chunk_size=1024):\n                        temp_file.write(chunk)\n                        file_size += len(chunk)\n                        if file_size > max_file_size_mb * 1024 * 1024:\n                            raise ValueError(f\"Downloaded file exceeds the size limit of {max_file_size_mb} MB\")\n\n                inspect(message=f\"Downloaded file to {temp_file_path}\")\n                \n                # After download is complete, move the file from temp to the final destination\n                shutil.move(temp_file_path, file_path)  # Move the file to final location\n\n                return file_path  # Return path of the final model file\n\n            else:\n                raise ValueError(f\"Failed to download file, status code: {response.status_code}\")\n\n        except Exception as e:\n            if os.path.exists(temp_file_path):\n                os.remove(temp_file_path)  # Clean up temporary file on error\n            raise ValueError(f\"Error downloading file: {e}\")\n\n@functools.lru_cache(maxsize=5)\ndef load_onnx_model(model_url: str, cache_dir: str = '/tmp/cache') -> ort.InferenceSession:\n    \"\"\"\n    Load an ONNX model into an ONNX Runtime session.\n\n    Args:\n        model_url (str): The URL or file path to the ONNX model.\n        cache_dir (str): Directory for caching or processing model files.\n\n    Returns:\n        ort.InferenceSession: The ONNX Runtime session for the loaded model.\n\n    Raises:\n        ValueError: If the model file cannot be processed or loaded.\n    \"\"\"\n    try:\n        # Process the model file to ensure it's a valid ONNX model\n        model_path = download_file_with_lock(model_url, cache_dir=cache_dir)\n\n        # Initialize the ONNX Runtime session\n        inspect(message=f\"Initializing ONNX Runtime session for model at {model_path}...\")\n        ort_session = ort.InferenceSession(model_path, providers=[\"CPUExecutionProvider\"])\n        inspect(message=\"ONNX model successfully loaded into ONNX Runtime session.\")\n        return ort_session\n\n    except Exception as e:\n        raise ValueError(f\"Failed to load the ONNX model from {model_url}. Error: {e}\")\n\ndef preprocess_input(input_xr: xr.DataArray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Preprocess the input DataArray by ensuring the dimensions are in the correct order,\n    reshaping it, and returning the reshaped numpy array and the original shape.\n    \"\"\"\n    inspect(message=f\"Preprocessing the input\")\n    input_xr = input_xr.transpose(\"y\", \"x\", \"bands\")\n    input_shape = input_xr.shape\n    input_np = input_xr.values.reshape(-1, ort_session.get_inputs()[0].shape[1])\n    return input_np, input_shape\n\ndef run_inference(input_np: np.ndarray, ort_session: ort.InferenceSession) -> tuple:\n    \"\"\"\n    Run inference using the ONNX runtime session and return predicted labels and probabilities.\n    \"\"\"\n    inspect(message=f\"Running inference\")\n    ort_inputs = {ort_session.get_inputs()[0].name: input_np}\n    ort_outputs = ort_session.run(None, ort_inputs)\n    predicted_labels = ort_outputs[0]\n    probabilities_dicts = ort_outputs[1]\n    return predicted_labels, probabilities_dicts\n\ndef postprocess_output(predicted_labels: np.ndarray, probabilities_dicts: list, input_shape: tuple) -> tuple:\n    \"\"\"\n    Postprocess the output by reshaping the predicted labels and probabilities into the original spatial structure.\n    \"\"\"\n\n    inspect(message=f\"Postprocessing the output\")\n    class_labels = list(probabilities_dicts[0].keys())\n\n    # Convert probabilities into a 2D array\n    probabilities = np.array([[prob[class_id] for class_id in class_labels] for prob in probabilities_dicts])\n\n    # Reshape to match the (y, x) spatial structure\n    predicted_labels = predicted_labels.reshape(input_shape[0], input_shape[1])\n    probabilities = probabilities.reshape(len(class_labels), input_shape[0], input_shape[1])\n\n    return predicted_labels, probabilities\n\ndef create_output_xarray(predicted_labels: np.ndarray, probabilities: np.ndarray, \n                         input_xr: xr.DataArray) -> xr.DataArray:\n    \"\"\"\n    Create an xarray DataArray with predicted labels and probabilities stacked along the bands dimension.\n    \"\"\"\n    inspect(message=f\"Ceating output xarray\")\n    #combined_data = np.concatenate([\n    #    predicted_labels[np.newaxis, :, :],  # Shape (1, y, x) for predicted labels\n    #    probabilities  # Shape (n_classes, y, x) for probabilities\n    #], axis=0)\n\n    return xr.DataArray(\n        probabilities,\n        dims=[\"bands\", \"y\", \"x\"],\n        coords={\n            'y': input_xr.coords['y'],\n            'x': input_xr.coords['x']\n        }\n    )\n\ndef apply_model(input_xr: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Run inference on the given input data using the provided ONNX runtime session.\n    This method is called for each timestep in the chunk received by apply_datacube.\n    \"\"\"\n    # Step 1: Load the ONNX model\n    try:\n        ort_session = load_onnx_model(context.get(\"model_url\"), cache_dir=\"/tmp/cache\")\n    except ValueError as e:\n        raise RuntimeError(f\"Model loading failed: {e}\")\n\n    # Step 2: Preprocess the input\n    input_np, input_shape = preprocess_input(input_xr, ort_session)\n\n    # Step 3: Perform inference\n    predicted_labels, probabilities_dicts = run_inference(input_np, ort_session)\n\n    # Step 4: Postprocess the output\n    predicted_labels, probabilities = postprocess_output(predicted_labels, probabilities_dicts, input_shape)\n\n    # Step 5: Create the output xarray\n    return create_output_xarray(predicted_labels, probabilities, input_xr)\n\ndef apply_datacube(cube: xr.DataArray, context: Dict) -> xr.DataArray:\n    \"\"\"\n    Function that is called for each chunk of data that is processed.\n    The function name and arguments are defined by the UDF API.\n    \n    More information can be found here: \n    https://open-eo.github.io/openeo-python-client/udf.html#udf-function-names-and-signatures\n\n    CAVEAT: Some users tend to extract the underlying numpy array and preprocess it for the model using Numpy functions.\n        The order of the dimensions in the numpy array might not be the same for each back-end or when running a udf locally, \n        which can lead to unexpected results. \n\n        It is recommended to use the named dimensions of the xarray DataArray to avoid this issue.\n        The order of the dimensions can be changed using the transpose method.\n        While it is a better practice to do preprocessing using openeo processes, most operations are also available in Xarray. \n    \"\"\"\n    # Define how you want to handle nan values\n    cube = cube.fillna(255)\n\n    # Apply the model for each timestep in the chunk\n    output_data = apply_model(cube, context)\n\n    return output_data"}, "process_id": "run_udf", "result": true}}}}, "process_id": "apply_dimension"}, "dropdimension1": {"arguments": {"data": {"from_node": "filterbbox2"}, "name": "t"}, "process_id": "drop_dimension"}, "filterbands1": {"arguments": {"bands": ["B02_p2", "B02_p25", "B02_median", "B02_p75", "B02_p98", "B02_mean", "B02_sd", "B02_sum", "B02_iqr", "B03_p2", "B03_p25", "B03_median", "B03_p75", "B03_p98", "B03_mean", "B03_sd", "B03_sum", "B03_iqr", "B04_p2", "B04_p25", "B04_median", "B04_p75", "B04_p98", "B04_mean", "B04_sd", "B04_sum", "B04_iqr", "B05_p2", "B05_p25", "B05_median", "B05_p75", "B05_p98", "B05_mean", "B05_sd", "B05_sum", "B05_iqr", "B06_p2", "B06_p25", "B06_median", "B06_p75", "B06_p98", "B06_mean", "B06_sd", "B06_sum", "B06_iqr", "B07_p2", "B07_p25", "B07_median", "B07_p75", "B07_p98", "B07_mean", "B07_sd", "B07_sum", "B07_iqr", "B08_p2", "B08_p25", "B08_median", "B08_p75", "B08_p98", "B08_mean", "B08_sd", "B08_sum", "B08_iqr", "B8A_p2", "B8A_p25", "B8A_median", "B8A_p75", "B8A_p98", "B8A_mean", "B8A_sd", "B8A_sum", "B8A_iqr", "B11_p2", "B11_p25", "B11_median", "B11_p75", "B11_p98", "B11_mean", "B11_sd", "B11_sum", "B11_iqr", "B12_p2", "B12_p25", "B12_median", "B12_p75", "B12_p98", "B12_mean", "B12_sd", "B12_sum", "B12_iqr", "NDVI_p2", "NDVI_p25", "NDVI_median", "NDVI_p75", "NDVI_p98", "NDVI_mean", "NDVI_sd", "NDVI_sum", "NDVI_iqr", "AVI_p2", "AVI_p25", "AVI_median", "AVI_p75", "AVI_p98", "AVI_mean", "AVI_sd", "AVI_sum", "AVI_iqr", "CIRE_p2", "CIRE_p25", "CIRE_median", "CIRE_p75", "CIRE_p98", "CIRE_mean", "CIRE_sd", "CIRE_sum", "CIRE_iqr", "NIRv_p2", "NIRv_p25", "NIRv_median", "NIRv_p75", "NIRv_p98", "NIRv_mean", "NIRv_sd", "NIRv_sum", "NIRv_iqr", "NDMI_p2", "NDMI_p25", "NDMI_median", "NDMI_p75", "NDMI_p98", "NDMI_mean", "NDMI_sd", "NDMI_sum", "NDMI_iqr", "NDWI_p2", "NDWI_p25", "NDWI_median", "NDWI_p75", "NDWI_p98", "NDWI_mean", "NDWI_sd", "NDWI_sum", "NDWI_iqr", "BLFEI_p2", "BLFEI_p25", "BLFEI_median", "BLFEI_p75", "BLFEI_p98", "BLFEI_mean", "BLFEI_sd", "BLFEI_sum", "BLFEI_iqr", "MNDWI_p2", "MNDWI_p25", "MNDWI_median", "MNDWI_p75", "MNDWI_p98", "MNDWI_mean", "MNDWI_sd", "MNDWI_sum", "MNDWI_iqr", "NDVIMNDWI_p2", "NDVIMNDWI_p25", "NDVIMNDWI_median", "NDVIMNDWI_p75", "NDVIMNDWI_p98", "NDVIMNDWI_mean", "NDVIMNDWI_sd", "NDVIMNDWI_sum", "NDVIMNDWI_iqr", "S2WI_p2", "S2WI_p25", "S2WI_median", "S2WI_p75", "S2WI_p98", "S2WI_mean", "S2WI_sd", "S2WI_sum", "S2WI_iqr", "S2REP_p2", "S2REP_p25", "S2REP_median", "S2REP_p75", "S2REP_p98", "S2REP_mean", "IRECI_p2", "IRECI_p25", "IRECI_median", "IRECI_p75", "IRECI_p98", "IRECI_mean", "IRECI_sd", "IRECI_sum", "IRECI_iqr", "VV_p2", "VV_p25", "VV_median", "VV_p75", "VV_p98", "VV_mean", "VV_sd", "VV_iqr", "VH_p2", "VH_p25", "VH_median", "VH_p75", "VH_p98", "VH_mean", "VH_sd", "VH_iqr", "RVI_p2", "RVI_p25", "RVI_median", "RVI_p75", "RVI_p98", "RVI_mean", "RVI_sd", "RVI_sum", "RVI_iqr", "VHVVD_p2", "VHVVD_p25", "VHVVD_median", "VHVVD_p75", "VHVVD_p98", "VHVVD_mean", "VHVVD_sd", "VHVVD_iqr", "VHVVR_p2", "VHVVR_p25", "VHVVR_median", "VHVVR_p75", "VHVVR_p98", "VHVVR_mean", "VHVVR_sd", "VHVVR_sum", "VHVVR_iqr"], "data": {"from_node": "renamelabels4"}}, "process_id": "filter_bands"}, "filterbands10": {"arguments": {"bands": ["CIRE_p98", "CIRE_mean", "NDVI_p98", "CIRE_iqr", "AVI_p98", "NIRv_p98", "IRECI_iqr", "CIRE_median", "IRECI_p98", "CIRE_sd", "CIRE_p75", "IRECI_sum", "IRECI_sd", "NIRv_mean", "VH_iqr", "IRECI_p75", "S2WI_iqr", "pop", "AVI_p75", "NIRv_sd", "IRECI_mean", "NIRv_p75", "NIRv_median", "NDVI_mean", "IRECI_median", "NIRv_iqr", "NDVI_p75", "BLFEI_p2", "NDMI_p75", "NDWI_p2", "NDMI_p98", "NDVI_median", "S2REP_p75", "NDVIMNDWI_p98", "VV_p98", "NDWI_p25", "NDWI_mean", "BLFEI_p25", "NDWI_median", "BLFEI_mean", "VV_p25", "NDVIMNDWI_p75", "B8A_median", "VV_p75", "VV_median", "AVI_sd", "VV_mean", "BLFEI_median", "BLFEI_p75", "NDVI_sd", "VH_p75", "VH_mean", "VH_p25", "VH_p98", "NDVI_iqr", "VH_median", "NDWI_sd", "B02_p75", "S2WI_sum", "B04_p2", "dist", "B11_sum"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands11": {"arguments": {"bands": ["gst", "DEM", "gdd5", "pop", "scd", "NDVI_median", "bdod", "B8A_sd", "dist", "clay", "B11_sd", "VH_p2", "NDVIMNDWI_sd", "B06_sd", "B07_sd", "B05_sum", "soc", "NDWI_median", "NDWI_sd", "VHVVR_sd", "NDVI_sum", "B12_sum", "sand", "NDWI_sum", "NDWI_p25", "RVI_sd", "bio12", "gsp", "VV_p2", "B04_sd", "VHVVR_p75", "NDWI_mean", "VV_p98", "phh2o", "B11_sum", "AVI_sd", "NDVI_p75", "VV_p25", "cfvo", "B05_p75", "VV_p75", "VH_p25", "B12_p75", "VV_median", "RVI_sum", "RVI_mean", "NIRv_iqr", "VH_mean", "MNDWI_sum", "B12_sd", "VHVVR_p98", "NDVIMNDWI_sum", "NDVI_p98", "VV_mean"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands12": {"arguments": {"bands": ["NDVI_median", "NDVI_mean", "NDVI_p75", "NDVI_p25", "NDVIMNDWI_median", "CIRE_mean", "BLFEI_median", "scd", "IRECI_median", "NDWI_p75", "VH_sd", "bio12", "NDWI_mean", "CIRE_p25", "NIRv_median", "IRECI_p25", "dist", "NDVIMNDWI_mean", "BLFEI_mean", "CIRE_median", "NDVIMNDWI_p25", "NIRv_p25", "NDVI_sum", "gdd5", "gsp", "DEM", "VH_p2", "NDWI_sum", "MNDWI_p75", "BLFEI_p75", "B05_p25", "NDVIMNDWI_sum", "B06_p25", "B8A_p25", "B06_median", "B07_p25", "VV_p2", "B08_p25", "occur", "VV_sd", "MNDWI_median", "B08_p2", "VH_mean", "MNDWI_mean", "NDVI_p2", "NIRv_p2", "CIRE_p2", "MNDWI_sum", "VV_mean", "VHVVD_p2", "B11_p25", "VHVVD_sd", "B12_p25", "NDWI_p98", "B12_p2", "S2WI_sum", "B11_p2", "MNDWI_p98", "NDVIMNDWI_p2", "S2WI_mean", "S2WI_p25", "gst"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands13": {"arguments": {"bands": ["B12_p2", "NIRv_p2", "NDVI_p2", "NDWI_p98", "S2WI_p25", "NDVIMNDWI_p2", "B11_p25", "B11_p2", "CIRE_p2", "B11_median", "B12_p25", "MNDWI_p98", "B11_mean", "B11_sum", "MNDWI_sum", "BLFEI_iqr", "AVI_p2", "BLFEI_p98", "B08_p2", "B08_p25", "B06_sum", "B12_sum", "B07_sum", "BLFEI_sd", "B8A_sum", "MNDWI_mean", "B08_sum", "B07_median", "BLFEI_sum", "IRECI_p2", "B05_p2", "B06_p2", "NDVIMNDWI_sum", "B8A_p2", "B8A_median", "NDWI_sum", "B07_p2", "B07_mean", "B8A_mean", "MNDWI_p75", "MNDWI_iqr", "NIRv_p25", "MNDWI_median", "IRECI_p25", "NIRv_sum", "B08_median", "B8A_p75", "NDVIMNDWI_mean", "B08_mean", "NIRv_median", "NDVIMNDWI_median", "NDWI_mean", "NDVIMNDWI_p25", "NIRv_mean", "S2WI_sd", "CIRE_sum", "NDWI_p75", "NDMI_sd", "VH_p25", "CIRE_p25", "NDWI_median", "B11_sd"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands14": {"arguments": {"bands": ["gsp", "sand", "bio12", "NIRv_p25", "AVI_p25", "S2REP_p75", "B08_p25", "VHVVD_p98", "cec", "dist", "S2REP_median", "B03_p25", "clay", "scd", "B12_mean", "B05_p75", "VV_iqr", "B05_p25", "B03_median", "DEM", "B05_median", "VHVVR_p2", "B11_median", "B05_mean", "B03_p75", "B03_mean", "RVI_p2", "VHVVD_median", "VV_p2", "cfvo", "VHVVD_mean", "B04_mean", "S2WI_p98", "VHVVD_p25", "VH_p2", "gdd5", "VV_sd", "bdod", "CIRE_p25", "B06_p98", "VHVVD_p75", "soc", "S2WI_sd", "AVI_median", "VH_sd", "NIRv_median", "gst", "AVI_p2", "B07_p25", "B06_p25"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands15": {"arguments": {"bands": ["DEM", "gdd5", "scd", "AVI_p25", "NIRv_p25", "cfvo", "gst", "B08_p25", "soc", "AVI_mean", "bio12", "IRECI_p25", "sand", "NIRv_median", "B02_sd", "NDWI_median", "B08_p98", "IRECI_median", "bdod", "NDVI_median", "CIRE_p25", "B03_sd", "gsp", "phh2o", "NDVIMNDWI_median", "BLFEI_median", "NDVI_p25", "clay", "NDWI_mean", "NDWI_p98", "NDWI_p75", "B11_p25", "BLFEI_sum", "B06_mean", "AVI_p2", "B06_p25", "S2REP_median", "B8A_p25", "B07_p25", "VHVVD_mean", "NIRv_p2", "B11_p98", "B08_p2", "B06_p75", "B08_mean", "VH_iqr", "AVI_p75", "S2WI_median", "AVI_median", "VHVVD_p25"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands16": {"arguments": {"bands": ["clay", "B11_p98", "sand", "scd", "VHVVD_p98", "B06_p25", "gsp", "bio12", "RVI_iqr", "VV_sd", "VH_sd", "cec", "B11_sum", "DEM", "dist", "gdd5", "gst", "S2WI_iqr", "B11_sd", "VV_median", "B03_mean", "soc", "B02_mean", "VHVVR_p75", "S2WI_median", "RVI_p75", "NDMI_p75", "cfvo", "RVI_p98", "VHVVR_p98", "VHVVR_mean", "VHVVR_sum", "VV_p75", "NDWI_mean", "B05_mean", "B12_mean", "B05_p98", "B03_sd", "B12_sd", "B02_sum", "NDVIMNDWI_mean", "B02_sd", "NIRv_p2", "NDVIMNDWI_p2", "B11_p75", "B02_p25", "B04_p98", "VHVVR_sd", "B02_p98", "B12_p98"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands17": {"arguments": {"bands": ["NDWI_p2", "B07_p25", "bdod", "NDVIMNDWI_p98", "B06_p25", "B8A_p25", "B06_median", "B08_p25", "B02_p2", "AVI_p2", "MNDWI_p2", "S2REP_p98", "B06_p2", "AVI_p25", "MNDWI_iqr", "B03_p2", "bio12", "B8A_median", "B07_median", "B04_p2", "S2REP_mean", "B12_p25", "B11_p25", "B05_p2", "VV_p98", "S2REP_p75", "VH_p98", "NIRv_p25", "S2REP_median", "VH_p75", "B12_p2", "soc", "B08_mean", "NDVIMNDWI_sd", "B07_mean", "NIRv_p2", "AVI_mean", "B06_mean", "BLFEI_p2", "NDWI_sd", "B8A_mean", "BLFEI_iqr", "cfvo", "NDVI_p98", "VH_p2", "B03_iqr", "B08_p98", "B05_iqr", "MNDWI_p25", "B8A_p98"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands18": {"arguments": {"bands": ["VH_p2", "B12_sd", "IRECI_p25", "gsp", "VH_median", "scd", "DEM", "gdd5", "BLFEI_p25", "NIRv_p25", "bio12", "phh2o", "B04_sum", "B07_iqr", "BLFEI_median", "gst", "S2WI_median", "B8A_mean", "B11_p98", "S2WI_p75", "RVI_p98", "VHVVR_p98", "VV_p98", "B07_mean", "B06_mean", "B07_median", "VHVVR_sd", "B8A_median", "VHVVR_p2", "dist", "VHVVR_iqr", "VV_p2", "NDMI_p98", "B06_median", "RVI_iqr", "RVI_sd", "CIRE_p2", "MNDWI_sd", "S2WI_mean", "NDVIMNDWI_sd", "B05_p98", "B08_mean", "B11_p2", "NDWI_p98", "S2WI_p25", "NIRv_mean", "IRECI_sum", "NDVIMNDWI_p2", "B03_p98", "VH_p25"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands19": {"arguments": {"bands": ["bio12", "B07_iqr", "B12_sd", "NIRv_sd", "AVI_sd", "B05_sd", "IRECI_iqr", "gsp", "NDVI_sum", "NDWI_sum", "IRECI_sd", "NIRv_iqr", "B06_iqr", "NDVI_iqr", "B03_p98", "NDVIMNDWI_sum", "B02_iqr", "IRECI_p98", "dist", "scd", "CIRE_sum", "B02_p98", "B12_iqr", "sand", "VHVVD_p25", "NDMI_median", "VHVVD_p2", "NIRv_p98", "gdd5", "B11_iqr", "B03_sd", "CIRE_mean", "B02_sd", "B11_p75", "AVI_p98", "VH_mean", "B11_sd", "VH_sd", "CIRE_median", "NDVI_p75", "S2WI_median", "NDVI_p98", "B12_p75", "CIRE_p98", "VV_p2", "S2WI_iqr", "VH_p2", "S2WI_sd", "VV_mean", "B11_median", "cec", "NDMI_mean", "NDMI_p75", "VV_sd", "B11_mean", "B02_p2", "B12_p25", "NDWI_p2", "B05_p25", "VHVVD_p75"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands2": {"arguments": {"bands": ["NDVI_p75", "BLFEI_p25", "NDWI_p25", "NDWI_median", "NDVIMNDWI_p75", "NDVI_median", "BLFEI_median", "CIRE_p75", "B12_sum", "bdod", "NDVI_mean", "NDVIMNDWI_median", "CIRE_mean", "CIRE_median", "phh2o", "IRECI_p98", "NDWI_mean", "IRECI_p75", "CIRE_sum", "BLFEI_p2", "NDVIMNDWI_mean", "BLFEI_mean", "IRECI_mean", "B12_p75", "IRECI_sd", "NDWI_p75", "B04_median", "IRECI_median", "NDVI_p25", "cfvo", "NDVI_p98", "NDVIMNDWI_p25", "CIRE_p98", "IRECI_sum", "NIRv_p75", "BLFEI_p75", "NIRv_median", "NIRv_p98", "NIRv_mean", "IRECI_iqr", "DEM", "B04_p25", "NDVIMNDWI_p98", "CIRE_p25", "gdd5", "AVI_p98", "B12_mean", "AVI_p75", "NIRv_sd", "soc", "VH_p25", "VH_iqr", "B12_median", "B02_median", "B04_p75", "B12_iqr", "NDVI_sum", "B11_sum", "AVI_mean", "B03_median", "CIRE_iqr", "B04_mean", "AVI_median", "B02_p75", "NIRv_iqr", "NIRv_sum", "B02_p25", "NDWI_p2", "BLFEI_sum", "B05_p75", "VH_mean", "B03_p75", "CIRE_sd", "B04_sum", "NDWI_sum", "NDMI_sd", "NDMI_median", "B05_median", "VH_median", "B05_sum", "pop", "NDVIMNDWI_sum", "NDVI_sd", "AVI_p25", "NIRv_p25", "B8A_p75", "S2WI_sum", "bio12", "NDVI_iqr", "VV_p25", "MNDWI_median", "B12_p25", "VH_p75", "MNDWI_p25", "scd", "NDMI_sum", "B8A_median", "B07_p75", "AVI_sd", "IRECI_p25", "NDMI_p75", "B07_iqr", "gst", "B8A_iqr", "VV_mean", "B05_mean", "B8A_mean", "CIRE_p2", "B05_p25", "B02_mean", "S2WI_iqr", "B11_p75", "B08_p75", "NDWI_p98", "VV_median", "clay", "B12_p98", "NDMI_mean", "NDVI_p2", "B8A_p25", "B11_mean", "B03_mean", "AVI_iqr", "MNDWI_p75", "VH_p2", "MNDWI_sum", "B06_p75", "NDMI_p98", "B03_p25"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands20": {"arguments": {"bands": ["gdd5", "gst", "scd", "cfvo", "bdod", "bio12", "B07_sum", "dist", "MNDWI_sum", "B08_sum", "BLFEI_sum", "AVI_sum", "NDVIMNDWI_sum", "B06_sum", "B8A_sum", "DEM", "S2WI_sum", "S2WI_p2", "NDWI_sum", "gsp", "NIRv_sum", "B12_sum", "B11_sum", "NDVI_sum", "soc", "B03_sum", "NDMI_p2", "NDVI_p25", "S2WI_p25", "B07_p2", "NDVIMNDWI_p2", "phh2o", "AVI_p2", "NIRv_p2", "NDWI_p98", "NDVI_p2", "B05_sum", "S2WI_mean", "B03_p98", "B8A_p2", "CIRE_p2", "S2REP_p75", "BLFEI_p98", "MNDWI_iqr", "MNDWI_sd", "B11_iqr", "B06_sd", "NDVIMNDWI_sd", "S2WI_iqr", "CIRE_sum"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands21": {"arguments": {"bands": ["gdd5", "DEM", "scd", "bdod", "gst", "bio12", "gsp", "soc", "cfvo", "NDMI_sd", "BLFEI_sum", "NDVIMNDWI_sum", "phh2o", "NDVI_iqr", "NDWI_sum", "AVI_sum", "MNDWI_sum", "NDMI_iqr", "B08_p75", "B07_p75", "NIRv_sum", "B08_sum", "B07_sum", "B8A_p75", "AVI_p75", "B06_median", "IRECI_sum", "NIRv_iqr", "B8A_sum", "NDVI_sum", "NIRv_sd", "AVI_median", "NIRv_p75", "IRECI_sd", "IRECI_iqr", "NDMI_p2", "B08_median", "CIRE_iqr", "NIRv_median", "clay", "VV_mean", "B06_sum", "IRECI_p98", "B07_median", "NIRv_mean", "AVI_iqr", "B07_p98", "AVI_mean", "B06_mean", "B08_mean", "NDWI_iqr", "B8A_iqr", "B07_iqr", "B8A_mean", "B06_p75", "CIRE_sd", "B07_mean", "IRECI_p75", "B8A_p98", "B03_p75", "B8A_median", "VV_median", "NIRv_p98", "BLFEI_iqr", "S2WI_p2", "B08_p98", "cec", "VV_p2", "AVI_p98", "VH_p75", "BLFEI_p25", "B08_iqr", "B02_p75", "S2WI_p98"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands22": {"arguments": {"bands": ["gdd5", "scd", "DEM", "bio12", "gst", "gsp", "cfvo", "bdod", "soc", "sand", "NDVIMNDWI_sum", "BLFEI_sum", "NDWI_sum", "MNDWI_sum", "NDVI_sum", "AVI_sum", "B8A_sum", "B07_sum", "cec", "B06_sum", "NIRv_sum", "B11_sum", "B08_sum", "B12_sum", "B05_sum", "VV_sd", "VHVVD_mean", "VH_sd", "IRECI_sum", "VHVVD_p75", "pop", "VHVVD_median", "VHVVR_sd", "VHVVD_p25", "VHVVD_p98", "RVI_mean", "RVI_sum", "RVI_median", "VHVVR_median", "VHVVR_sum", "VHVVR_mean", "RVI_sd", "VH_mean", "RVI_p25", "dist", "VHVVR_p75", "B06_iqr", "VV_p25", "RVI_p75", "B04_sum", "VHVVR_p25", "B03_iqr", "B11_p25", "S2WI_p25", "VH_median", "MNDWI_iqr", "MNDWI_p75", "IRECI_p98", "MNDWI_mean", "VH_p25", "VV_mean", "S2WI_mean", "S2REP_p75", "B03_sum", "VV_p98", "VH_p98", "S2WI_p75", "B11_p2", "MNDWI_median", "B12_p2", "S2WI_sum", "B02_iqr", "B05_iqr", "VH_p2", "S2WI_median", "RVI_p2", "B8A_p25", "S2REP_p25", "clay", "CIRE_sd", "NDVI_p98", "VV_p2", "IRECI_p75", "NDMI_p98", "B07_p25", "NDWI_p25", "B8A_p75", "S2WI_p98", "B8A_mean", "VHVVR_p2", "CIRE_p98", "B06_mean", "B07_p75", "B06_p75", "VHVVD_sd", "AVI_mean", "B08_median", "VHVVD_iqr"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands23": {"arguments": {"bands": ["scd", "gst", "sand", "bio12", "DEM", "gdd5", "NDVI_median", "NDVIMNDWI_sum", "NDWI_sum", "NDVI_sum", "BLFEI_sum", "CIRE_sum", "cec", "cfvo", "CIRE_median", "NDWI_median", "MNDWI_sum", "BLFEI_median", "NDVIMNDWI_p25", "BLFEI_p75", "NDWI_p75", "IRECI_sum", "CIRE_mean", "NDVIMNDWI_median", "AVI_sum", "NIRv_sum", "CIRE_p75", "bdod", "NDVI_p25", "B07_sum", "B02_median", "B8A_sum", "BLFEI_mean", "B03_p25", "CIRE_p98", "soc", "NDVI_mean", "NDWI_mean", "BLFEI_p25", "NDVIMNDWI_mean", "NDVIMNDWI_p75", "NDWI_p25", "BLFEI_p2", "NDVI_p75", "B02_p25", "B04_median", "MNDWI_p2", "B04_p75", "B02_p75", "B08_sum"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands24": {"arguments": {"bands": ["phh2o", "BLFEI_sum", "NDVI_sum", "MNDWI_sum", "NDWI_sum", "cfvo", "NDVIMNDWI_sum", "clay", "VH_sd", "cec", "VV_sd", "B05_iqr", "B02_p75", "B02_iqr", "VV_p2", "AVI_sum", "scd", "gdd5", "B08_sum", "B8A_sum", "B05_sd", "dist", "RVI_p2", "VHVVR_p2", "B07_sum", "VH_p2", "NDMI_sum", "B06_sum", "bio12", "gsp", "sand", "VHVVD_sd", "B11_sum", "VHVVD_p98", "RVI_sd", "IRECI_p25", "B07_p25", "NDVI_p25", "B06_p25", "NDVI_iqr", "CIRE_sum", "CIRE_p75", "gst", "B02_mean", "MNDWI_median", "B02_sd", "B03_mean", "BLFEI_sd", "VHVVD_iqr", "RVI_p25"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands3": {"arguments": {"bands": ["B12_p25", "B12_median", "B05_sum", "B11_p25", "B11_median", "B12_p75", "B05_p75", "B04_p25", "B05_median", "B12_mean", "B12_sum", "NDMI_median", "B12_p2", "B04_p2", "B04_median", "gst", "NDMI_mean", "B02_p25", "B02_p2", "NIRv_iqr", "B07_iqr", "NDMI_sum", "DEM", "S2WI_p25", "B04_sum", "B03_p25", "B07_p75", "IRECI_iqr", "scd", "B11_p75", "B11_sum", "B05_mean", "NDMI_p25", "bio12", "B04_p75", "S2WI_p98", "B08_median", "B03_median", "B06_p75", "NIRv_sd", "gsp", "B05_p25", "B06_iqr", "B03_p2", "B04_mean", "IRECI_sd", "B08_p75", "S2WI_median", "B08_iqr", "MNDWI_p75", "gdd5", "B04_iqr", "VH_p75", "BLFEI_p75", "B12_iqr", "S2WI_mean", "B11_mean", "NDWI_p75", "NDMI_p75", "B8A_median", "B05_p98", "B06_median", "VV_mean", "B02_median", "NDMI_p98", "B07_median", "NDVI_p25", "CIRE_p25", "B08_p25", "B07_mean", "B08_mean"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands4": {"arguments": {"bands": ["gdd5", "DEM", "scd", "gst", "bio12", "cfvo", "soc", "gsp", "sand", "VV_p2", "NDVI_sum", "NDWI_sum", "BLFEI_sum", "NDVIMNDWI_sum", "VH_p2", "MNDWI_sum", "AVI_sum", "VH_sd", "CIRE_p25", "NDWI_p75", "NIRv_sum", "NDWI_p98", "NDVIMNDWI_p2", "CIRE_sum", "VV_sd", "B02_p98", "NDVI_p25", "BLFEI_p98", "B8A_sum", "B03_p98", "NDVI_mean", "NDVI_median", "pop", "IRECI_sum", "B07_sum", "NDWI_mean", "B06_sum", "phh2o", "NIRv_median", "clay", "NIRv_mean", "bdod", "NDVI_p2", "NIRv_p25", "cec", "MNDWI_p98", "BLFEI_sd", "B08_sum", "dist", "CIRE_median", "IRECI_p25", "AVI_mean", "NIRv_p2", "CIRE_mean", "IRECI_median", "NDWI_median", "NDVIMNDWI_p25", "S2WI_mean", "NDMI_sd", "NDVIMNDWI_mean", "B11_sum", "NDVIMNDWI_iqr", "IRECI_p2", "NDVI_sd", "AVI_p25", "NDWI_iqr", "NDVIMNDWI_median", "S2WI_median"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands5": {"arguments": {"bands": ["scd", "bio12", "cfvo", "soc", "DEM", "gdd5", "bdod", "gsp", "sand", "dist", "B08_p25", "gst", "B8A_p25", "B08_median", "B06_p25", "B07_p25", "AVI_p25", "B08_mean", "AVI_mean", "AVI_median", "VV_p2", "RVI_p2", "B07_median", "VHVVR_p2", "VH_p2", "B8A_mean", "B06_mean", "clay", "B06_median", "NIRv_p25", "B07_mean", "NIRv_median", "phh2o", "B11_sum", "B08_sum", "AVI_sum", "MNDWI_sum", "B12_sum", "BLFEI_sum", "B05_sum", "RVI_p25", "VHVVR_p25", "NDWI_p75", "VV_mean", "NDVI_p25", "RVI_median", "VHVVR_median", "cec", "NDVI_sum", "NDVIMNDWI_sum", "B11_p75", "NDWI_sum", "BLFEI_median", "RVI_mean", "RVI_sum", "VH_mean", "VHVVR_sum", "VHVVR_p75", "RVI_p75", "B03_p25", "B04_p25", "NDWI_median", "B03_median", "VV_p25", "VV_p75", "VV_median", "B11_mean", "NDMI_p2", "B02_p25", "B02_median", "B12_median", "B11_median", "S2WI_p98", "B11_p25", "VH_median", "IRECI_p25", "VH_p75", "VH_p25", "S2WI_sd", "VHVVD_p75", "B11_iqr", "VHVVD_p25", "VHVVD_mean", "VHVVD_median", "pop"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands6": {"arguments": {"bands": ["gdd5", "DEM", "scd", "soc", "gst", "bio12", "cfvo", "bdod", "B11_sum", "MNDWI_sum", "phh2o", "B12_sum", "BLFEI_sum", "B8A_sum", "AVI_sum", "B07_sum", "gsp", "B08_sum", "B06_sum", "NDVIMNDWI_sum", "S2WI_mean", "clay", "sand", "NDMI_p2", "S2WI_p25", "NDWI_sum", "S2WI_sum", "S2WI_p75", "S2WI_median", "B05_sum", "NDMI_p25", "NDMI_mean", "NIRv_sum", "B11_mean", "B12_p75", "NDVI_sum", "B04_sum", "B12_mean", "cec", "NDWI_p75", "B11_median", "B12_median", "NDMI_median", "B03_sum", "S2WI_p2", "B12_p25", "B11_p25", "NDMI_p98", "IRECI_iqr", "B11_p75", "IRECI_sum", "NDVI_mean", "NDVI_p25", "B02_sum", "dist", "NDMI_iqr", "B12_p2", "B02_p75", "B02_median", "B04_iqr", "S2WI_p98", "B11_p2", "NDWI_mean", "B05_p75", "CIRE_iqr", "NDWI_iqr", "B03_p75", "pop", "MNDWI_mean", "IRECI_p25", "B04_median", "B04_p2", "BLFEI_iqr", "B04_p25", "B05_mean", "B03_median", "B05_p25", "B05_median", "MNDWI_p75", "NDWI_median", "CIRE_sum", "IRECI_sd", "MNDWI_p2", "B05_p2", "BLFEI_mean", "B02_p25", "CIRE_median", "B03_p25", "B8A_p98", "IRECI_p75"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands7": {"arguments": {"bands": ["IRECI_iqr", "IRECI_sd", "NIRv_p98", "IRECI_sum", "AVI_p98", "CIRE_iqr", "NIRv_iqr", "B8A_p75", "IRECI_p98", "B8A_iqr", "B07_iqr", "IRECI_p75", "NIRv_sd", "B07_p75", "B08_sum", "B8A_sum", "B07_sum", "B11_sum", "NDMI_p2", "DEM", "B08_p98", "B8A_median", "gdd5", "scd", "B8A_mean", "B07_p98", "B11_mean", "B8A_p98", "AVI_iqr", "B08_p75", "B11_p75", "B11_p25", "NIRv_p75", "AVI_sum", "B07_mean", "B08_iqr", "B11_median", "S2WI_p2", "AVI_sd", "AVI_p75", "B12_sum", "IRECI_mean", "B06_p75", "B06_sum", "gst", "S2WI_p25", "B06_iqr", "bio12", "B08_sd", "MNDWI_sum", "B07_median", "B07_sd", "B8A_sd", "S2WI_sum", "B12_mean", "B06_p98", "S2WI_mean", "soc", "bdod", "B06_median", "NIRv_mean", "B12_p75", "B08_mean", "B06_sd", "S2WI_median", "gsp", "CIRE_sd", "NIRv_median", "sand", "NDVI_sd", "B08_median", "BLFEI_p25", "MNDWI_median", "MNDWI_p75", "clay", "NDVI_iqr", "BLFEI_sum", "NDMI_iqr", "S2WI_p75", "AVI_median", "MNDWI_mean", "cec", "BLFEI_mean", "BLFEI_sd", "BLFEI_iqr", "NDVIMNDWI_sum", "cfvo", "NDVIMNDWI_p75", "NIRv_p2", "S2WI_sd", "VHVVD_median", "B05_median", "MNDWI_p25", "B04_p75", "MNDWI_p2", "NDVIMNDWI_sd", "CIRE_p75", "B04_median", "VHVVD_p75", "BLFEI_median", "NDVI_p98", "B03_median", "S2REP_p25", "NDWI_sum", "B02_p25", "B05_p2", "MNDWI_sd", "BLFEI_p75", "S2REP_p98", "NDWI_median", "NDVIMNDWI_p98", "NDVI_p75", "S2WI_iqr", "NDWI_p25", "CIRE_sum", "VHVVR_p25", "B02_median", "NDMI_p75", "B03_p25", "BLFEI_p2", "RVI_p25", "NDVIMNDWI_median", "S2WI_p98", "NDVI_median", "VHVVD_p98", "S2REP_median", "MNDWI_iqr", "NDVIMNDWI_mean", "VHVVD_p25", "S2REP_p75", "B04_iqr", "VV_p2", "CIRE_p98", "dist", "VV_sd", "VHVVR_median", "NDWI_p75", "B02_p75", "B07_p2", "RVI_median", "B03_p2", "RVI_mean", "RVI_sum", "phh2o", "NDWI_mean", "VV_mean", "B11_sd", "NDVIMNDWI_p25", "B02_mean", "B06_p2", "VV_p25", "VV_median", "NDWI_p2", "NDVI_sum", "RVI_p2", "VHVVR_p2", "CIRE_median", "B06_p25", "VH_mean", "VHVVR_sum", "VHVVR_mean", "B03_iqr", "VH_sd", "VH_p25"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands8": {"arguments": {"bands": ["NDVIMNDWI_sum", "BLFEI_sum", "NDWI_sum", "CIRE_sum", "bio12", "IRECI_sum", "NDVI_sum", "AVI_sum", "MNDWI_sum", "NIRv_sum", "B08_sum", "scd", "gdd5", "B11_sum", "B8A_sum", "DEM", "soc", "B07_sum", "IRECI_mean", "NDWI_median", "IRECI_p75", "CIRE_median", "cfvo", "B06_sum", "NDVI_p75", "NIRv_median", "NDVI_median", "NDWI_mean", "gst", "CIRE_p75", "NDVIMNDWI_mean", "NDWI_p25", "BLFEI_median", "bdod", "cec", "sand", "CIRE_mean", "BLFEI_p25", "NDVIMNDWI_p75", "IRECI_median", "NDVI_mean", "BLFEI_p2", "NDWI_p2", "IRECI_p98", "IRECI_iqr", "NDVIMNDWI_p98", "CIRE_iqr", "B04_p25", "IRECI_sd", "BLFEI_mean", "MNDWI_median", "gsp", "B12_sum", "MNDWI_p2", "NDVI_p98", "S2WI_sd", "NDVI_p2", "S2WI_p2", "B03_mean", "B02_p2", "B03_sum", "B02_sum", "phh2o", "B03_p25", "B04_median"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbands9": {"arguments": {"bands": ["bio12", "scd", "DEM", "B12_iqr", "gdd5", "gsp", "B05_iqr", "NDMI_p2", "NDMI_iqr", "soc", "cfvo", "NDVI_p2", "B04_sd", "B04_p98", "NDVI_p25", "BLFEI_p98", "NDVIMNDWI_p2", "VH_mean", "gst", "B02_p98", "VH_p2", "B12_p75", "B11_sd", "B12_sd", "NDVI_sd", "NDVI_iqr", "NDMI_sd", "B04_iqr", "NDWI_iqr", "S2WI_iqr", "NDWI_sd", "B04_sum", "B12_sum", "clay", "phh2o", "S2WI_p98", "S2WI_sd", "S2REP_p75", "B02_sum", "B05_p75", "B04_p75", "B03_sum", "B06_p98", "B02_median", "sand", "B12_mean", "B11_p75", "B07_p98", "NDMI_p25", "S2REP_median"], "data": {"from_node": "mergecubes3"}}, "process_id": "filter_bands"}, "filterbbox1": {"arguments": {"data": {"from_node": "resamplespatial3"}, "extent": {"crs": "EPSG:3035", "east": 4832000, "north": 2819000, "south": 2818000, "west": 4831000}}, "process_id": "filter_bbox"}, "filterbbox2": {"arguments": {"data": {"from_node": "resamplespatial4"}, "extent": {"crs": "EPSG:3035", "east": 4832000, "north": 2819000, "south": 2818000, "west": 4831000}}, "process_id": "filter_bbox"}, "loadcollection1": {"arguments": {"bands": ["B02", "B03", "B04", "B05", "B06", "B07", "B08", "B8A", "B11", "B12"], "id": "SENTINEL2_L2A", "properties": {"eo:cloud_cover": {"process_graph": {"lte1": {"arguments": {"x": {"from_parameter": "value"}, "y": 95}, "process_id": "lte", "result": true}}}}, "spatial_extent": {"crs": "EPSG:3035", "east": 4832000, "north": 2819000, "south": 2818000, "west": 4831000}, "temporal_extent": ["2021-01-01", "2021-02-01"]}, "process_id": "load_collection"}, "loadcollection2": {"arguments": {"bands": ["SCL"], "id": "SENTINEL2_L2A", "properties": {"eo:cloud_cover": {"process_graph": {"lte2": {"arguments": {"x": {"from_parameter": "value"}, "y": 95}, "process_id": "lte", "result": true}}}}, "spatial_extent": {"crs": "EPSG:3035", "east": 4832000, "north": 2819000, "south": 2818000, "west": 4831000}, "temporal_extent": ["2021-01-01", "2021-02-01"]}, "process_id": "load_collection"}, "loadcollection3": {"arguments": {"bands": ["VH", "VV"], "id": "SENTINEL1_GRD", "properties": {"sat:orbit_state": {"process_graph": {"eq1": {"arguments": {"x": {"from_parameter": "value"}, "y": "DESCENDING"}, "process_id": "eq", "result": true}}}}, "spatial_extent": {"crs": "EPSG:3035", "east": 4832000, "north": 2819000, "south": 2818000, "west": 4831000}, "temporal_extent": ["2021-01-01", "2021-02-01"]}, "process_id": "load_collection"}, "loadcollection4": {"arguments": {"bands": ["DEM"], "id": "COPERNICUS_30", "spatial_extent": null, "temporal_extent": null}, "process_id": "load_collection"}, "loadstac1": {"arguments": {"url": "https://stac.openeo.vito.be/collections/wenr_features"}, "process_id": "load_stac"}, "mask1": {"arguments": {"data": {"from_node": "resamplespatial1"}, "mask": {"from_node": "renamelabels1"}}, "process_id": "mask"}, "mergecubes1": {"arguments": {"cube1": {"from_node": "renamelabels2"}, "cube2": {"from_node": "renamelabels3"}}, "process_id": "merge_cubes"}, "mergecubes10": {"arguments": {"cube1": {"from_node": "mergecubes9"}, "cube2": {"from_node": "renamelabels12"}}, "process_id": "merge_cubes"}, "mergecubes11": {"arguments": {"cube1": {"from_node": "mergecubes10"}, "cube2": {"from_node": "renamelabels13"}}, "process_id": "merge_cubes"}, "mergecubes12": {"arguments": {"cube1": {"from_node": "mergecubes11"}, "cube2": {"from_node": "renamelabels14"}}, "process_id": "merge_cubes"}, "mergecubes13": {"arguments": {"cube1": {"from_node": "mergecubes12"}, "cube2": {"from_node": "renamelabels15"}}, "process_id": "merge_cubes"}, "mergecubes14": {"arguments": {"cube1": {"from_node": "mergecubes13"}, "cube2": {"from_node": "renamelabels16"}}, "process_id": "merge_cubes"}, "mergecubes15": {"arguments": {"cube1": {"from_node": "mergecubes14"}, "cube2": {"from_node": "renamelabels17"}}, "process_id": "merge_cubes"}, "mergecubes16": {"arguments": {"cube1": {"from_node": "mergecubes15"}, "cube2": {"from_node": "renamelabels18"}}, "process_id": "merge_cubes"}, "mergecubes17": {"arguments": {"cube1": {"from_node": "mergecubes16"}, "cube2": {"from_node": "renamelabels19"}}, "process_id": "merge_cubes"}, "mergecubes18": {"arguments": {"cube1": {"from_node": "mergecubes17"}, "cube2": {"from_node": "renamelabels20"}}, "process_id": "merge_cubes"}, "mergecubes19": {"arguments": {"cube1": {"from_node": "mergecubes18"}, "cube2": {"from_node": "renamelabels21"}}, "process_id": "merge_cubes"}, "mergecubes2": {"arguments": {"cube1": {"from_node": "filterbands1"}, "cube2": {"from_node": "filterbbox1"}}, "process_id": "merge_cubes"}, "mergecubes20": {"arguments": {"cube1": {"from_node": "mergecubes19"}, "cube2": {"from_node": "renamelabels22"}}, "process_id": "merge_cubes"}, "mergecubes21": {"arguments": {"cube1": {"from_node": "mergecubes20"}, "cube2": {"from_node": "renamelabels23"}}, "process_id": "merge_cubes"}, "mergecubes22": {"arguments": {"cube1": {"from_node": "mergecubes21"}, "cube2": {"from_node": "renamelabels24"}}, "process_id": "merge_cubes"}, "mergecubes23": {"arguments": {"cube1": {"from_node": "mergecubes22"}, "cube2": {"from_node": "renamelabels25"}}, "process_id": "merge_cubes"}, "mergecubes24": {"arguments": {"cube1": {"from_node": "mergecubes23"}, "cube2": {"from_node": "renamelabels26"}}, "process_id": "merge_cubes"}, "mergecubes25": {"arguments": {"cube1": {"from_node": "mergecubes24"}, "cube2": {"from_node": "renamelabels27"}}, "process_id": "merge_cubes"}, "mergecubes3": {"arguments": {"cube1": {"from_node": "mergecubes2"}, "cube2": {"from_node": "dropdimension1"}}, "process_id": "merge_cubes"}, "mergecubes4": {"arguments": {"cube1": {"from_node": "renamelabels5"}, "cube2": {"from_node": "renamelabels6"}}, "process_id": "merge_cubes"}, "mergecubes5": {"arguments": {"cube1": {"from_node": "mergecubes4"}, "cube2": {"from_node": "renamelabels7"}}, "process_id": "merge_cubes"}, "mergecubes6": {"arguments": {"cube1": {"from_node": "mergecubes5"}, "cube2": {"from_node": "renamelabels8"}}, "process_id": "merge_cubes"}, "mergecubes7": {"arguments": {"cube1": {"from_node": "mergecubes6"}, "cube2": {"from_node": "renamelabels9"}}, "process_id": "merge_cubes"}, "mergecubes8": {"arguments": {"cube1": {"from_node": "mergecubes7"}, "cube2": {"from_node": "renamelabels10"}}, "process_id": "merge_cubes"}, "mergecubes9": {"arguments": {"cube1": {"from_node": "mergecubes8"}, "cube2": {"from_node": "renamelabels11"}}, "process_id": "merge_cubes"}, "reducedimension1": {"arguments": {"data": {"from_node": "loadcollection4"}, "dimension": "t", "reducer": {"process_graph": {"last1": {"arguments": {"data": {"from_parameter": "data"}, "ignore_nodata": true}, "process_id": "last", "result": true}}}}, "process_id": "reduce_dimension"}, "renamelabels1": {"arguments": {"data": {"from_node": "toscldilationmask1"}, "dimension": "bands", "target": ["S2-L2A-SCL_DILATED_MASK"]}, "process_id": "rename_labels"}, "renamelabels10": {"arguments": {"data": {"from_node": "applydimension11"}, "dimension": "bands", "target": ["Level2_class-G_164predictors_v1_70100", "Level2_class-G_164predictors_v1_70200", "Level2_class-G_164predictors_v1_70300", "Level2_class-G_164predictors_v1_70400"]}, "process_id": "rename_labels"}, "renamelabels11": {"arguments": {"data": {"from_node": "applydimension12"}, "dimension": "bands", "target": ["Level2_class-H_65predictors_v1_80200", "Level2_class-H_65predictors_v1_80300"]}, "process_id": "rename_labels"}, "renamelabels12": {"arguments": {"data": {"from_node": "applydimension13"}, "dimension": "bands", "target": ["Level2_class-I_50predictors_v1_90100", "Level2_class-I_50predictors_v1_90200"]}, "process_id": "rename_labels"}, "renamelabels13": {"arguments": {"data": {"from_node": "applydimension14"}, "dimension": "bands", "target": ["Level2_class-J_62predictors_v1_100100", "Level2_class-J_62predictors_v1_100200", "Level2_class-J_62predictors_v1_100300", "Level2_class-J_62predictors_v1_100400", "Level2_class-J_62predictors_v1_100600"]}, "process_id": "rename_labels"}, "renamelabels14": {"arguments": {"data": {"from_node": "applydimension15"}, "dimension": "bands", "target": ["Level2_class-X_54predictors_v1_110400", "Level2_class-X_54predictors_v1_110700", "Level2_class-X_54predictors_v1_110800", "Level2_class-X_54predictors_v1_110900", "Level2_class-X_54predictors_v1_112100"]}, "process_id": "rename_labels"}, "renamelabels15": {"arguments": {"data": {"from_node": "applydimension16"}, "dimension": "bands", "target": ["Level3_class-C1_62predictors_v1_30102", "Level3_class-C1_62predictors_v1_30103", "Level3_class-C1_62predictors_v1_30104"]}, "process_id": "rename_labels"}, "renamelabels16": {"arguments": {"data": {"from_node": "applydimension17"}, "dimension": "bands", "target": ["Level3_class-C3_62predictors_v1_30302", "Level3_class-C3_62predictors_v1_30304", "Level3_class-C3_62predictors_v1_30305"]}, "process_id": "rename_labels"}, "renamelabels17": {"arguments": {"data": {"from_node": "applydimension18"}, "dimension": "bands", "target": ["Level3_class-E1_50predictors_v1_50101", "Level3_class-E1_50predictors_v1_50102"]}, "process_id": "rename_labels"}, "renamelabels18": {"arguments": {"data": {"from_node": "applydimension19"}, "dimension": "bands", "target": ["Level3_class-E2_50predictors_v1_50201", "Level3_class-E2_50predictors_v1_50202", "Level3_class-E2_50predictors_v1_50203", "Level3_class-E2_50predictors_v1_50206"]}, "process_id": "rename_labels"}, "renamelabels19": {"arguments": {"data": {"from_node": "applydimension20"}, "dimension": "bands", "target": ["Level3_class-E3_50predictors_v1_50304", "Level3_class-E3_50predictors_v1_50305"]}, "process_id": "rename_labels"}, "renamelabels2": {"arguments": {"data": {"from_node": "applydimension1"}, "dimension": "bands", "target": ["B02", "B03", "B04", "B05", "B06", "B07", "B08", "B8A", "B11", "B12", "NDVI", "AVI", "CIRE", "NIRv", "NDMI", "NDWI", "BLFEI", "MNDWI", "NDVIMNDWI", "S2WI", "S2REP", "IRECI"]}, "process_id": "rename_labels"}, "renamelabels20": {"arguments": {"data": {"from_node": "applydimension21"}, "dimension": "bands", "target": ["Level3_class-E4_50predictors_v1_50403", "Level3_class-E4_50predictors_v1_50404"]}, "process_id": "rename_labels"}, "renamelabels21": {"arguments": {"data": {"from_node": "applydimension22"}, "dimension": "bands", "target": ["Level3_class-E5_50predictors_v1_50504", "Level3_class-E5_50predictors_v1_50505"]}, "process_id": "rename_labels"}, "renamelabels22": {"arguments": {"data": {"from_node": "applydimension23"}, "dimension": "bands", "target": ["Level3_class-F2_60predictors_v1_60202", "Level3_class-F2_60predictors_v1_60203", "Level3_class-F2_60predictors_v1_60204"]}, "process_id": "rename_labels"}, "renamelabels23": {"arguments": {"data": {"from_node": "applydimension24"}, "dimension": "bands", "target": ["Level3_class-F3_50predictors_v1_60301", "Level3_class-F3_50predictors_v1_60302"]}, "process_id": "rename_labels"}, "renamelabels24": {"arguments": {"data": {"from_node": "applydimension25"}, "dimension": "bands", "target": ["Level3_class-G1_74predictors_v1_70101", "Level3_class-G1_74predictors_v1_70102", "Level3_class-G1_74predictors_v1_70104", "Level3_class-G1_74predictors_v1_70105", "Level3_class-G1_74predictors_v1_70106", "Level3_class-G1_74predictors_v1_70107", "Level3_class-G1_74predictors_v1_70108", "Level3_class-G1_74predictors_v1_70110", "Level3_class-G1_74predictors_v1_70113"]}, "process_id": "rename_labels"}, "renamelabels25": {"arguments": {"data": {"from_node": "applydimension26"}, "dimension": "bands", "target": ["Level3_class-G3_98predictors_v1_70301", "Level3_class-G3_98predictors_v1_70302", "Level3_class-G3_98predictors_v1_70304", "Level3_class-G3_98predictors_v1_70314"]}, "process_id": "rename_labels"}, "renamelabels26": {"arguments": {"data": {"from_node": "applydimension27"}, "dimension": "bands", "target": ["Level3_class-H2_50predictors_v1_80203", "Level3_class-H2_50predictors_v1_80204", "Level3_class-H2_50predictors_v1_80206"]}, "process_id": "rename_labels"}, "renamelabels27": {"arguments": {"data": {"from_node": "applydimension28"}, "dimension": "bands", "target": ["Level3_class-H3_50predictors_v1_80301", "Level3_class-H3_50predictors_v1_80302", "Level3_class-H3_50predictors_v1_80306"]}, "process_id": "rename_labels"}, "renamelabels3": {"arguments": {"data": {"from_node": "applydimension4"}, "dimension": "bands", "target": ["VV", "VH", "RVI", "VHVVD", "VHVVR"]}, "process_id": "rename_labels"}, "renamelabels4": {"arguments": {"data": {"from_node": "applydimension5"}, "dimension": "bands", "target": ["B02_p2", "B02_p25", "B02_median", "B02_p75", "B02_p98", "B02_mean", "B02_sd", "B02_sum", "B02_iqr", "B03_p2", "B03_p25", "B03_median", "B03_p75", "B03_p98", "B03_mean", "B03_sd", "B03_sum", "B03_iqr", "B04_p2", "B04_p25", "B04_median", "B04_p75", "B04_p98", "B04_mean", "B04_sd", "B04_sum", "B04_iqr", "B05_p2", "B05_p25", "B05_median", "B05_p75", "B05_p98", "B05_mean", "B05_sd", "B05_sum", "B05_iqr", "B06_p2", "B06_p25", "B06_median", "B06_p75", "B06_p98", "B06_mean", "B06_sd", "B06_sum", "B06_iqr", "B07_p2", "B07_p25", "B07_median", "B07_p75", "B07_p98", "B07_mean", "B07_sd", "B07_sum", "B07_iqr", "B08_p2", "B08_p25", "B08_median", "B08_p75", "B08_p98", "B08_mean", "B08_sd", "B08_sum", "B08_iqr", "B8A_p2", "B8A_p25", "B8A_median", "B8A_p75", "B8A_p98", "B8A_mean", "B8A_sd", "B8A_sum", "B8A_iqr", "B11_p2", "B11_p25", "B11_median", "B11_p75", "B11_p98", "B11_mean", "B11_sd", "B11_sum", "B11_iqr", "B12_p2", "B12_p25", "B12_median", "B12_p75", "B12_p98", "B12_mean", "B12_sd", "B12_sum", "B12_iqr", "NDVI_p2", "NDVI_p25", "NDVI_median", "NDVI_p75", "NDVI_p98", "NDVI_mean", "NDVI_sd", "NDVI_sum", "NDVI_iqr", "AVI_p2", "AVI_p25", "AVI_median", "AVI_p75", "AVI_p98", "AVI_mean", "AVI_sd", "AVI_sum", "AVI_iqr", "CIRE_p2", "CIRE_p25", "CIRE_median", "CIRE_p75", "CIRE_p98", "CIRE_mean", "CIRE_sd", "CIRE_sum", "CIRE_iqr", "NIRv_p2", "NIRv_p25", "NIRv_median", "NIRv_p75", "NIRv_p98", "NIRv_mean", "NIRv_sd", "NIRv_sum", "NIRv_iqr", "NDMI_p2", "NDMI_p25", "NDMI_median", "NDMI_p75", "NDMI_p98", "NDMI_mean", "NDMI_sd", "NDMI_sum", "NDMI_iqr", "NDWI_p2", "NDWI_p25", "NDWI_median", "NDWI_p75", "NDWI_p98", "NDWI_mean", "NDWI_sd", "NDWI_sum", "NDWI_iqr", "BLFEI_p2", "BLFEI_p25", "BLFEI_median", "BLFEI_p75", "BLFEI_p98", "BLFEI_mean", "BLFEI_sd", "BLFEI_sum", "BLFEI_iqr", "MNDWI_p2", "MNDWI_p25", "MNDWI_median", "MNDWI_p75", "MNDWI_p98", "MNDWI_mean", "MNDWI_sd", "MNDWI_sum", "MNDWI_iqr", "NDVIMNDWI_p2", "NDVIMNDWI_p25", "NDVIMNDWI_median", "NDVIMNDWI_p75", "NDVIMNDWI_p98", "NDVIMNDWI_mean", "NDVIMNDWI_sd", "NDVIMNDWI_sum", "NDVIMNDWI_iqr", "S2WI_p2", "S2WI_p25", "S2WI_median", "S2WI_p75", "S2WI_p98", "S2WI_mean", "S2WI_sd", "S2WI_sum", "S2WI_iqr", "S2REP_p2", "S2REP_p25", "S2REP_median", "S2REP_p75", "S2REP_p98", "S2REP_mean", "S2REP_sd", "S2REP_sum", "S2REP_iqr", "IRECI_p2", "IRECI_p25", "IRECI_median", "IRECI_p75", "IRECI_p98", "IRECI_mean", "IRECI_sd", "IRECI_sum", "IRECI_iqr", "VV_p2", "VV_p25", "VV_median", "VV_p75", "VV_p98", "VV_mean", "VV_sd", "VV_sum", "VV_iqr", "VH_p2", "VH_p25", "VH_median", "VH_p75", "VH_p98", "VH_mean", "VH_sd", "VH_sum", "VH_iqr", "RVI_p2", "RVI_p25", "RVI_median", "RVI_p75", "RVI_p98", "RVI_mean", "RVI_sd", "RVI_sum", "RVI_iqr", "VHVVD_p2", "VHVVD_p25", "VHVVD_median", "VHVVD_p75", "VHVVD_p98", "VHVVD_mean", "VHVVD_sd", "VHVVD_sum", "VHVVD_iqr", "VHVVR_p2", "VHVVR_p25", "VHVVR_median", "VHVVR_p75", "VHVVR_p98", "VHVVR_mean", "VHVVR_sd", "VHVVR_sum", "VHVVR_iqr"]}, "process_id": "rename_labels"}, "renamelabels5": {"arguments": {"data": {"from_node": "applydimension6"}, "dimension": "bands", "target": ["Level1_class-0_129predictors_v1_30000", "Level1_class-0_129predictors_v1_40000", "Level1_class-0_129predictors_v1_50000", "Level1_class-0_129predictors_v1_60000", "Level1_class-0_129predictors_v1_70000", "Level1_class-0_129predictors_v1_80000", "Level1_class-0_129predictors_v1_90000", "Level1_class-0_129predictors_v1_100000", "Level1_class-0_129predictors_v1_110000"]}, "process_id": "rename_labels"}, "renamelabels6": {"arguments": {"data": {"from_node": "applydimension7"}, "dimension": "bands", "target": ["Level2_class-C_71predictors_v1_30100", "Level2_class-C_71predictors_v1_30200", "Level2_class-C_71predictors_v1_30300"]}, "process_id": "rename_labels"}, "renamelabels7": {"arguments": {"data": {"from_node": "applydimension8"}, "dimension": "bands", "target": ["Level2_class-D_68predictors_v1_40100", "Level2_class-D_68predictors_v1_40200", "Level2_class-D_68predictors_v1_40400", "Level2_class-D_68predictors_v1_40500"]}, "process_id": "rename_labels"}, "renamelabels8": {"arguments": {"data": {"from_node": "applydimension9"}, "dimension": "bands", "target": ["Level2_class-E_85predictors_v1_50100", "Level2_class-E_85predictors_v1_50200", "Level2_class-E_85predictors_v1_50300", "Level2_class-E_85predictors_v1_50400", "Level2_class-E_85predictors_v1_50500", "Level2_class-E_85predictors_v1_50600"]}, "process_id": "rename_labels"}, "renamelabels9": {"arguments": {"data": {"from_node": "applydimension10"}, "dimension": "bands", "target": ["Level2_class-F_90predictors_v1_60200", "Level2_class-F_90predictors_v1_60300", "Level2_class-F_90predictors_v1_60400", "Level2_class-F_90predictors_v1_60900", "Level2_class-F_90predictors_v1_61100"]}, "process_id": "rename_labels"}, "resamplespatial1": {"arguments": {"align": "upper-left", "data": {"from_node": "loadcollection1"}, "method": "near", "projection": 3035, "resolution": 10}, "process_id": "resample_spatial"}, "resamplespatial2": {"arguments": {"align": "upper-left", "data": {"from_node": "sarbackscatter1"}, "method": "near", "projection": 3035, "resolution": 10}, "process_id": "resample_spatial"}, "resamplespatial3": {"arguments": {"align": "upper-left", "data": {"from_node": "reducedimension1"}, "method": "bilinear", "projection": 3035, "resolution": 10}, "process_id": "resample_spatial"}, "resamplespatial4": {"arguments": {"align": "upper-left", "data": {"from_node": "loadstac1"}, "method": "near", "projection": 3035, "resolution": 10}, "process_id": "resample_spatial"}, "sarbackscatter1": {"arguments": {"coefficient": "sigma0-ellipsoid", "contributing_area": false, "data": {"from_node": "loadcollection3"}, "elevation_model": "COPERNICUS_30", "ellipsoid_incidence_angle": false, "local_incidence_angle": false, "mask": false, "noise_removal": true, "options": {"debug": false, "elev_geoid": "/opt/openeo-vito-aux-data/egm96.tif", "implementation_version": "2", "otb_memory": 1024, "tile_size": 256}}, "process_id": "sar_backscatter"}, "saveresult1": {"arguments": {"data": {"from_node": "mergecubes25"}, "format": "GTiff", "options": {"separate_asset_per_band": true}}, "process_id": "save_result", "result": true}, "toscldilationmask1": {"arguments": {"data": {"from_node": "loadcollection2"}, "erosion_kernel_size": 3, "kernel1_size": 17, "kernel2_size": 77, "mask1_values": [2, 4, 5, 6, 7], "mask2_values": [3, 8, 9, 10, 11], "scl_band_name": "SCL"}, "process_id": "to_scl_dilation_mask"}}, "format": "openeo"}, "processing:facility": "openEO Geotrellis backend", "processing:software": {"Geotrellis backend": "0.52.0a1"}, "roles": ["processor"]}], "stac_extensions": ["https://stac-extensions.github.io/eo/v1.1.0/schema.json", "https://stac-extensions.github.io/file/v2.1.0/schema.json", "https://stac-extensions.github.io/processing/v1.1.0/schema.json", "https://stac-extensions.github.io/projection/v1.1.0/schema.json"], "stac_version": "1.0.0", "summaries": {}, "title": "multimodal_inference", "type": "Collection"}